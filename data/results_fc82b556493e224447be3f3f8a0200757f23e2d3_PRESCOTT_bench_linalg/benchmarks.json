{
    "bench_app.LaplaceInplace.time_it": {
        "code": "class LaplaceInplace:\n    def time_it(self, update):\n        self.run()\n\n    def setup(self, update):\n        N = 150\n        Niter = 1000\n        dx = 0.1\n        dy = 0.1\n        dx2 = (dx * dx)\n        dy2 = (dy * dy)\n    \n        def num_update(u, dx2, dy2):\n            u[1:(-1), 1:(-1)] = ((((u[2:, 1:(-1)] + u[:(-2), 1:(-1)]) * dy2) +\n                                  ((u[1:(-1), 2:] + u[1:(-1), :(-2)]) * dx2))\n                                 / (2 * (dx2 + dy2)))\n    \n        def num_inplace(u, dx2, dy2):\n            tmp = u[:(-2), 1:(-1)].copy()\n            np.add(tmp, u[2:, 1:(-1)], out=tmp)\n            np.multiply(tmp, dy2, out=tmp)\n            tmp2 = u[1:(-1), 2:].copy()\n            np.add(tmp2, u[1:(-1), :(-2)], out=tmp2)\n            np.multiply(tmp2, dx2, out=tmp2)\n            np.add(tmp, tmp2, out=tmp)\n            np.multiply(tmp, (1.0 / (2.0 * (dx2 + dy2))),\n                        out=u[1:(-1), 1:(-1)])\n    \n        def laplace(N, Niter=100, func=num_update, args=()):\n            u = np.zeros([N, N], order='C')\n            u[0] = 1\n            for i in range(Niter):\n                func(u, *args)\n            return u\n    \n        func = {'inplace': num_inplace, 'normal': num_update}[update]\n    \n        def run():\n            laplace(N, Niter, func, args=(dx2, dy2))\n    \n        self.run = run",
        "min_run_count": 2,
        "name": "bench_app.LaplaceInplace.time_it",
        "number": 0,
        "param_names": [
            "update"
        ],
        "params": [
            [
                "'inplace'",
                "'normal'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e912d48a31445b41d3721a0504b60aa72ddb03e4689b8386bdca5446901fa5ba",
        "warmup_time": -1
    },
    "bench_app.MaxesOfDots.time_it": {
        "code": "class MaxesOfDots:\n    def time_it(self):\n        self.maxes_of_dots(self.arrays)\n\n    def setup(self):\n        np.random.seed(1)\n        nsubj = 5\n        nfeat = 100\n        ntime = 200\n    \n        self.arrays = [np.random.normal(size=(ntime, nfeat))\n                       for i in range(nsubj)]",
        "min_run_count": 2,
        "name": "bench_app.MaxesOfDots.time_it",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c35d6b0cbd7e439f6dc9f9844f9a6aac5e1702e666595106714a3ffb372b6be0",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array": {
        "code": "class ArrayCoercionSmall:\n    def time_array(self, array_like):\n        np.array(array_like)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "02bfee29f8ec04abfab771e56eca7f16ee6c7505c0797230455fe5d972c374db",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array_all_kwargs": {
        "code": "class ArrayCoercionSmall:\n    def time_array_all_kwargs(self, array_like):\n        np.array(array_like, dtype=self.int64, copy=None, order=\"F\",\n                 subok=False, ndmin=2)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array_all_kwargs",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ea106909fd00186ac50284fd3b227e95110d36081a76bef98fc23b569d2f81b6",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array_dtype_not_kwargs": {
        "code": "class ArrayCoercionSmall:\n    def time_array_dtype_not_kwargs(self, array_like):\n        np.array(array_like, self.int64)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array_dtype_not_kwargs",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7406ad0e996196d58688b676695446cdc1975aec380a82035209732e57ae47b8",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array_invalid_kwarg": {
        "code": "class ArrayCoercionSmall:\n    def time_array_invalid_kwarg(self, array_like):\n        try:\n            np.array(array_like, ndmin=\"not-integer\")\n        except TypeError:\n            pass",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array_invalid_kwarg",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3cf138af2df1bdfa905afad9a2c8f4769ea6f86eef956764982c6922a78b59a8",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array_no_copy": {
        "code": "class ArrayCoercionSmall:\n    def time_array_no_copy(self, array_like):\n        np.array(array_like, copy=None)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array_no_copy",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a7c001798b225e74384cd251d475621f5a37cbc80d8af484c7ab0512cf147518",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_array_subok": {
        "code": "class ArrayCoercionSmall:\n    def time_array_subok(self, array_like):\n        np.array(array_like, subok=True)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_array_subok",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2dc6919d9d4310f83b980f79ffd1353c7af92663d2ec75157574c06e7c075276",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_asanyarray": {
        "code": "class ArrayCoercionSmall:\n    def time_asanyarray(self, array_like):\n        np.asanyarray(array_like)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_asanyarray",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cc146235b50cf0c4134cdfd17bad7b1ef05003e7255c4963e97445a66e7118ae",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_asanyarray_dtype": {
        "code": "class ArrayCoercionSmall:\n    def time_asanyarray_dtype(self, array_like):\n        np.asanyarray(array_like, dtype=self.int64, order=\"F\")",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_asanyarray_dtype",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "614f42c0e903dfab317c8408e71efffefb879a5ce096c3c0b2c9c9ba25a88168",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_asarray": {
        "code": "class ArrayCoercionSmall:\n    def time_asarray(self, array_like):\n        np.asarray(array_like)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_asarray",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8fb148d93aa9d31468b9cdfa937d40b8fe600c94ff71e244f7153884f3ccf4c1",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_asarray_dtype": {
        "code": "class ArrayCoercionSmall:\n    def time_asarray_dtype(self, array_like):\n        np.asarray(array_like, dtype=self.int64, order=\"F\")",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_asarray_dtype",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d14925bac5cae539af082df7f2b7432b7453255ce77833e97cbd9e50bdaf239c",
        "warmup_time": -1
    },
    "bench_array_coercion.ArrayCoercionSmall.time_ascontiguousarray": {
        "code": "class ArrayCoercionSmall:\n    def time_ascontiguousarray(self, array_like):\n        np.ascontiguousarray(array_like)",
        "min_run_count": 2,
        "name": "bench_array_coercion.ArrayCoercionSmall.time_ascontiguousarray",
        "number": 0,
        "param_names": [
            "array_like"
        ],
        "params": [
            [
                "range(0, 3)",
                "[1]",
                "1",
                "array([5])",
                "np.int64(5)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "274ebaa23a30c9368e2ff6d82c13b62ec653a7d4736f01f1fa8921021769aea1",
        "warmup_time": -1
    },
    "bench_clip.ClipFloat.time_clip": {
        "code": "class ClipFloat:\n    def time_clip(self, dtype, size):\n        np.clip(self.array, 0.125, 0.875, self.dataout)\n\n    def setup(self, dtype, size):\n        rnd = np.random.RandomState(994584855)\n        self.array = rnd.random(size=size).astype(dtype)\n        self.dataout = np.full_like(self.array, 0.5)",
        "min_run_count": 2,
        "name": "bench_clip.ClipFloat.time_clip",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'numpy.longdouble'>"
            ],
            [
                "100",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9c7655302d8fa13e6d5258072225408697d8cf76696577f20a0bc8f4608f7e9f",
        "warmup_time": -1
    },
    "bench_clip.ClipInteger.time_clip": {
        "code": "class ClipInteger:\n    def time_clip(self, dtype, size):\n        np.clip(self.array, 32, 224, self.dataout)\n\n    def setup(self, dtype, size):\n        rnd = np.random.RandomState(1301109903)\n        self.array = rnd.randint(256, size=size, dtype=dtype)\n        self.dataout = np.full_like(self.array, 128)",
        "min_run_count": 2,
        "name": "bench_clip.ClipInteger.time_clip",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>"
            ],
            [
                "100",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d73cd9eb92c1c4f186687a36c47c3aea40363c65021b5c8668fa211c5a588ab7",
        "warmup_time": -1
    },
    "bench_core.Core.time_arange_100": {
        "code": "class Core:\n    def time_arange_100(self):\n        np.arange(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_arange_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9810ff39cf0d90038a0f034783bd846b9b7de314928b7ed9b77a9db9ab62a515",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_1": {
        "code": "class Core:\n    def time_array_1(self):\n        np.array(1)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "aebef56aaf9fb83a7a269cd2353e0e3ee094f80cd9aa5ee2224a71dec34d1b08",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_empty": {
        "code": "class Core:\n    def time_array_empty(self):\n        np.array([])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_empty",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9a1586e568107cf4face75cecd6781c6359af578ef730c85a4f752eec1dbaa9a",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_float64_l1000": {
        "code": "class Core:\n    def time_array_float64_l1000(self):\n        np.array(self.float64_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_float64_l1000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ccc5ca6d62274d036ae686dadc52f3d09e242ad9cd57d2c408da0b39d1943914",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_float_l1000": {
        "code": "class Core:\n    def time_array_float_l1000(self):\n        np.array(self.float_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_float_l1000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "461053b7868bf5b2057d2bab87037b5e07c6cf938871cb3766b44a69b8270f18",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_float_l1000_dtype": {
        "code": "class Core:\n    def time_array_float_l1000_dtype(self):\n        np.array(self.float_l1000, dtype=self.float64_dtype)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_float_l1000_dtype",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3bb7c63d26535c89a4bddc30b2aa5f74488ffae091736b6622e911af9a30ae1f",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_int_l1000": {
        "code": "class Core:\n    def time_array_int_l1000(self):\n        np.array(self.int_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_int_l1000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "89e8dee6420ae63d274cc4a6beb3038a46fbd62faf80b1e485adb3a00ad4a359",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_l": {
        "code": "class Core:\n    def time_array_l(self):\n        np.array(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_l",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "68192f51161df9d033cd5f2090e414b700ecf573b2e9000b0c534223dbbd1289",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_l1": {
        "code": "class Core:\n    def time_array_l1(self):\n        np.array([1])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_l1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "241cdb1e469ff23c8c0308f3ff7813b606f280f0100c323d4ee3ae9f85da5595",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_l100": {
        "code": "class Core:\n    def time_array_l100(self):\n        np.array(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_l100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d704ac86a6671472c3625d12d6408848665f9db0ce76872e4893c6444287df7a",
        "warmup_time": -1
    },
    "bench_core.Core.time_array_l_view": {
        "code": "class Core:\n    def time_array_l_view(self):\n        np.array(self.l_view)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_array_l_view",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ece084f922536234f4dd58a4601dbcbebf246861708e32f5d4051d21acbae2b8",
        "warmup_time": -1
    },
    "bench_core.Core.time_can_cast": {
        "code": "class Core:\n    def time_can_cast(self):\n        np.can_cast(self.l10x10, self.float64_dtype)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_can_cast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e8db77b1f8f8809ad2582a5bf538b8249418d3c1674e56d2c90c598d502d77c1",
        "warmup_time": -1
    },
    "bench_core.Core.time_can_cast_same_kind": {
        "code": "class Core:\n    def time_can_cast_same_kind(self):\n        np.can_cast(self.l10x10, self.float64_dtype, casting=\"same_kind\")\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_can_cast_same_kind",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9671899093a9277922f2068c0bc39086ff21aca28bad218e2b76b8873652ff75",
        "warmup_time": -1
    },
    "bench_core.Core.time_diag_l100": {
        "code": "class Core:\n    def time_diag_l100(self):\n        np.diag(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_diag_l100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6e62ecc1856911a7a4997e46036370168fbcef6da55f9cdc14425052fd6af8a3",
        "warmup_time": -1
    },
    "bench_core.Core.time_diagflat_l100": {
        "code": "class Core:\n    def time_diagflat_l100(self):\n        np.diagflat(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_diagflat_l100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cf3eeccf300cf54e62332841fe4e1d22f44208d6b3a264cb5a2260121fd752bd",
        "warmup_time": -1
    },
    "bench_core.Core.time_diagflat_l50_l50": {
        "code": "class Core:\n    def time_diagflat_l50_l50(self):\n        np.diagflat([self.l50, self.l50])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_diagflat_l50_l50",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d2b890e26851599c8e29b40dbdabc8dbf1fa8dd62196cccbf9666f96e6f8e2e3",
        "warmup_time": -1
    },
    "bench_core.Core.time_dstack_l": {
        "code": "class Core:\n    def time_dstack_l(self):\n        np.dstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_dstack_l",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "61b3007741cca1eb312f112e40a2f4904676511eed1d9717f70f35d37d4e69fe",
        "warmup_time": -1
    },
    "bench_core.Core.time_empty_100": {
        "code": "class Core:\n    def time_empty_100(self):\n        np.empty(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_empty_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "559d67381ed0945a2d30dd05ea10953cb54301944e11e550dd7cda8b87253ca5",
        "warmup_time": -1
    },
    "bench_core.Core.time_empty_like": {
        "code": "class Core:\n    def time_empty_like(self):\n        np.empty_like(self.l10x10)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_empty_like",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a6df7577d8b7330bd3b5470ed79d8ac26e9df336bb41935a3d4934dd4161326d",
        "warmup_time": -1
    },
    "bench_core.Core.time_eye_100": {
        "code": "class Core:\n    def time_eye_100(self):\n        np.eye(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_eye_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "56a9ccc305d01ef5ac1e6fa57132076e313f1806b7b24edf967e272484072655",
        "warmup_time": -1
    },
    "bench_core.Core.time_eye_3000": {
        "code": "class Core:\n    def time_eye_3000(self):\n        np.eye(3000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_eye_3000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "824c99e7affa09c806961a580afaa51cf639bc65ddb114543fc2fe22952f33ff",
        "warmup_time": -1
    },
    "bench_core.Core.time_hstack_l": {
        "code": "class Core:\n    def time_hstack_l(self):\n        np.hstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_hstack_l",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "144b89def72fc1ce8633c9877160d7e1ef3e5d60fcca6715f3baff628acde755",
        "warmup_time": -1
    },
    "bench_core.Core.time_identity_100": {
        "code": "class Core:\n    def time_identity_100(self):\n        np.identity(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_identity_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d46f8b9fda8d7af1e55aaee2a9707a32f556309f127f324c3f0f9e14577f9c84",
        "warmup_time": -1
    },
    "bench_core.Core.time_identity_3000": {
        "code": "class Core:\n    def time_identity_3000(self):\n        np.identity(3000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_identity_3000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f25f09f407fc0ec65996e154ce1acc3605fbfc1956b2e45ab7a8be95eabe9742",
        "warmup_time": -1
    },
    "bench_core.Core.time_ones_100": {
        "code": "class Core:\n    def time_ones_100(self):\n        np.ones(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_ones_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f5f2fda543a06557ed577505581a4e4a69c28db7f4d56d15e3a5ab70c5836ad1",
        "warmup_time": -1
    },
    "bench_core.Core.time_tril_indices_500": {
        "code": "class Core:\n    def time_tril_indices_500(self):\n        np.tril_indices(500)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_tril_indices_500",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b00c8c298dd9483448ee0601526273d6576350e7cbff10d47b606a7182b9ee51",
        "warmup_time": -1
    },
    "bench_core.Core.time_tril_l10x10": {
        "code": "class Core:\n    def time_tril_l10x10(self):\n        np.tril(self.l10x10)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_tril_l10x10",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "52a8d958bc2f0d6641959d60b4e362bd13ff07ad07cb91f67c86c1371049d522",
        "warmup_time": -1
    },
    "bench_core.Core.time_triu_indices_500": {
        "code": "class Core:\n    def time_triu_indices_500(self):\n        np.triu_indices(500)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_triu_indices_500",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e67074fcc7b979a87a1080d3203b5ed9afac0744671de5d1ffb13cba5e2c27f4",
        "warmup_time": -1
    },
    "bench_core.Core.time_triu_l10x10": {
        "code": "class Core:\n    def time_triu_l10x10(self):\n        np.triu(self.l10x10)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_triu_l10x10",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "450bc906f82b3446c2c3ce69ea043137dc643848b9378c0387b7f50b18e99216",
        "warmup_time": -1
    },
    "bench_core.Core.time_vstack_l": {
        "code": "class Core:\n    def time_vstack_l(self):\n        np.vstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_vstack_l",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1287e18f3b28dadd8b9aca804e354546ffb3b238647b20cf3667d86e88c9412e",
        "warmup_time": -1
    },
    "bench_core.Core.time_zeros_100": {
        "code": "class Core:\n    def time_zeros_100(self):\n        np.zeros(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)",
        "min_run_count": 2,
        "name": "bench_core.Core.time_zeros_100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "206e21887f58c043e2d286405ddabefa934a6cecc80fbe3045636dee7df139a4",
        "warmup_time": -1
    },
    "bench_core.CorrConv.time_convolve": {
        "code": "class CorrConv:\n    def time_convolve(self, size1, size2, mode):\n        np.convolve(self.x1, self.x2, mode=mode)\n\n    def setup(self, size1, size2, mode):\n        self.x1 = np.linspace(0, 1, num=size1)\n        self.x2 = np.cos(np.linspace(0, 2*np.pi, num=size2))",
        "min_run_count": 2,
        "name": "bench_core.CorrConv.time_convolve",
        "number": 0,
        "param_names": [
            "size1",
            "size2",
            "mode"
        ],
        "params": [
            [
                "50",
                "1000",
                "100000"
            ],
            [
                "10",
                "100",
                "1000",
                "10000"
            ],
            [
                "'valid'",
                "'same'",
                "'full'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "110934cc16c781cf51ef05e32d0376573f652f8d29632088314c80bb280373f5",
        "warmup_time": -1
    },
    "bench_core.CorrConv.time_correlate": {
        "code": "class CorrConv:\n    def time_correlate(self, size1, size2, mode):\n        np.correlate(self.x1, self.x2, mode=mode)\n\n    def setup(self, size1, size2, mode):\n        self.x1 = np.linspace(0, 1, num=size1)\n        self.x2 = np.cos(np.linspace(0, 2*np.pi, num=size2))",
        "min_run_count": 2,
        "name": "bench_core.CorrConv.time_correlate",
        "number": 0,
        "param_names": [
            "size1",
            "size2",
            "mode"
        ],
        "params": [
            [
                "50",
                "1000",
                "100000"
            ],
            [
                "10",
                "100",
                "1000",
                "10000"
            ],
            [
                "'valid'",
                "'same'",
                "'full'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9add985c37891263767f640a8caa0571b67ad9fc64587e26fa1403cdbfd46a20",
        "warmup_time": -1
    },
    "bench_core.CountNonzero.time_count_nonzero": {
        "code": "class CountNonzero:\n    def time_count_nonzero(self, numaxes, size, dtype):\n        np.count_nonzero(self.x)\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_core.CountNonzero.time_count_nonzero",
        "number": 0,
        "param_names": [
            "numaxes",
            "size",
            "dtype"
        ],
        "params": [
            [
                "1",
                "2",
                "3"
            ],
            [
                "100",
                "10000",
                "1000000"
            ],
            [
                "<class 'bool'>",
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'str'>",
                "<class 'object'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "62b6e7f8cdf194df64c7d1c6948ebe3b15027b688ac851c288b08bf147ea21c4",
        "warmup_time": -1
    },
    "bench_core.CountNonzero.time_count_nonzero_axis": {
        "code": "class CountNonzero:\n    def time_count_nonzero_axis(self, numaxes, size, dtype):\n        np.count_nonzero(self.x, axis=self.x.ndim - 1)\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_core.CountNonzero.time_count_nonzero_axis",
        "number": 0,
        "param_names": [
            "numaxes",
            "size",
            "dtype"
        ],
        "params": [
            [
                "1",
                "2",
                "3"
            ],
            [
                "100",
                "10000",
                "1000000"
            ],
            [
                "<class 'bool'>",
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'str'>",
                "<class 'object'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0af13d073c97801eefc841f06735f316331f6898842d60d7077063e761cc3399",
        "warmup_time": -1
    },
    "bench_core.CountNonzero.time_count_nonzero_multi_axis": {
        "code": "class CountNonzero:\n    def time_count_nonzero_multi_axis(self, numaxes, size, dtype):\n        if self.x.ndim >= 2:\n            np.count_nonzero(self.x, axis=(\n                self.x.ndim - 1, self.x.ndim - 2))\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_core.CountNonzero.time_count_nonzero_multi_axis",
        "number": 0,
        "param_names": [
            "numaxes",
            "size",
            "dtype"
        ],
        "params": [
            [
                "1",
                "2",
                "3"
            ],
            [
                "100",
                "10000",
                "1000000"
            ],
            [
                "<class 'bool'>",
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'str'>",
                "<class 'object'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "539135a464660d1aa5d3e83d59b995843997e3e31d51e8e284bfbd83ddad52d3",
        "warmup_time": -1
    },
    "bench_core.Indices.time_indices": {
        "code": "class Indices:\n    def time_indices(self):\n        np.indices((1000, 500))",
        "min_run_count": 2,
        "name": "bench_core.Indices.time_indices",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2e230aa0719ef3ade68215df513a0a9aafa9d052ee5c2665559e3cea10bf9b51",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_add_big_list_small_string": {
        "code": "class NumPyChar:\n    def time_add_big_list_small_string(self):\n        np.char.add(self.B, self.B)\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_add_big_list_small_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a6228b2a9c056d9825fe49d131db70a02e9852ec20e9b63cfbe3a4e130e0d0c0",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_add_small_list_big_string": {
        "code": "class NumPyChar:\n    def time_add_small_list_big_string(self):\n        np.char.add(self.A, self.A)\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_add_small_list_big_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "db50979d133aacb317cc4af9e0ddc1e910dc8440618c21330a160e78573a298c",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_find_big_list_small_string": {
        "code": "class NumPyChar:\n    def time_find_big_list_small_string(self):\n        np.char.find(self.D, 'b')\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_find_big_list_small_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e598e38574a45a10e73e0d7781a1c8a380d4bb8f073a1a13d91f7a8393c4cfa6",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_find_small_list_big_string": {
        "code": "class NumPyChar:\n    def time_find_small_list_big_string(self):\n        np.char.find(self.C, 'z')\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_find_small_list_big_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e7eb6e6db1d6c0aae2ebfc8271711eb6cfdc5fbb3e812acdadd9a2ae606811a5",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_isalpha_big_list_small_string": {
        "code": "class NumPyChar:\n    def time_isalpha_big_list_small_string(self):\n        np.char.isalpha(self.B)\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_isalpha_big_list_small_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3732696138b1d9eaa2569e096dfff043d8a77e3ec8be909ffffb1d4bdb3d9751",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_isalpha_small_list_big_string": {
        "code": "class NumPyChar:\n    def time_isalpha_small_list_big_string(self):\n        np.char.isalpha(self.A)\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_isalpha_small_list_big_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e5b6b861dc7530c341afd619b1cfffeb95407096984735b356f8acdbbfa73c09",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_startswith_big_list_small_string": {
        "code": "class NumPyChar:\n    def time_startswith_big_list_small_string(self):\n        np.char.startswith(self.B, 'a')\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_startswith_big_list_small_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "19bc0c238917e6ba8670bcb85838675ef0654b3336cf230b9cee7612d4f79b99",
        "warmup_time": -1
    },
    "bench_core.NumPyChar.time_startswith_small_list_big_string": {
        "code": "class NumPyChar:\n    def time_startswith_small_list_big_string(self):\n        np.char.startswith(self.A, 'x')\n\n    def setup(self):\n        self.A = np.array([100*'x', 100*'y'])\n        self.B = np.array(1000 * ['aa'])\n    \n        self.C = np.array([100*'x' + 'z', 100*'y' + 'z' + 'y', 100*'x'])\n        self.D = np.array(1000 * ['ab'] + 1000 * ['ac'])",
        "min_run_count": 2,
        "name": "bench_core.NumPyChar.time_startswith_small_list_big_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1ce204cfe37e9bddece08d2dd6f163b4e404b7fa2485c127189e99d0d45acb4f",
        "warmup_time": -1
    },
    "bench_core.PackBits.time_packbits": {
        "code": "class PackBits:\n    def time_packbits(self, dtype):\n        np.packbits(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_core.PackBits.time_packbits",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'bool'>",
                "<class 'numpy.uint64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1e1cdd058f7cb55eb592d5d4a6d37273683a1ab55041e8c4b4ef7c29e5e55313",
        "warmup_time": -1
    },
    "bench_core.PackBits.time_packbits_axis0": {
        "code": "class PackBits:\n    def time_packbits_axis0(self, dtype):\n        np.packbits(self.d2, axis=0)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_core.PackBits.time_packbits_axis0",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'bool'>",
                "<class 'numpy.uint64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3596f631e5980c6f39f8af219cc1bd8bc6cb97ed103fbb9008368ce8e4510c0c",
        "warmup_time": -1
    },
    "bench_core.PackBits.time_packbits_axis1": {
        "code": "class PackBits:\n    def time_packbits_axis1(self, dtype):\n        np.packbits(self.d2, axis=1)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_core.PackBits.time_packbits_axis1",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'bool'>",
                "<class 'numpy.uint64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "138b6e3b289ecabf2012d7d40274f69f848fc241c53fe21eb8dcf5ff77dc3dd2",
        "warmup_time": -1
    },
    "bench_core.PackBits.time_packbits_little": {
        "code": "class PackBits:\n    def time_packbits_little(self, dtype):\n        np.packbits(self.d, bitorder=\"little\")\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_core.PackBits.time_packbits_little",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'bool'>",
                "<class 'numpy.uint64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b40e33398c541441ca74f3b9af0da0e187cd290dcb8f1c4040cd21b942212b93",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_max": {
        "code": "class StatsMethods:\n    def time_max(self, dtype, size):\n        self.data.max()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_max",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "745accf784a3761a614e47814900ce38353b52a05c0eb728bca99a9009119bc2",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_mean": {
        "code": "class StatsMethods:\n    def time_mean(self, dtype, size):\n        self.data.mean()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_mean",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2e8625e9c08bd3797b18d52ee20272ca22389da2bd69e370a55e9cdbcd098203",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_min": {
        "code": "class StatsMethods:\n    def time_min(self, dtype, size):\n        self.data.min()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_min",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fa3a60dbd3d869a58d009656b14f38ea4845738b13317011c78d02ad0d3c7baa",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_prod": {
        "code": "class StatsMethods:\n    def time_prod(self, dtype, size):\n        self.data.prod()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_prod",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5b2feeaf217945b9bbd169fe70890cd90b3986fe4629e4b3ce7b3a287428baa6",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_std": {
        "code": "class StatsMethods:\n    def time_std(self, dtype, size):\n        self.data.std()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_std",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "515d55a3ba06f7fc49a2e067f92eed47bd6aaad86fda69014c3b024c6ce91650",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_sum": {
        "code": "class StatsMethods:\n    def time_sum(self, dtype, size):\n        self.data.sum()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_sum",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "10e2f43ff5b6af15cb8c9260f82f6572f407579d35e83be479e298e8521af7df",
        "warmup_time": -1
    },
    "bench_core.StatsMethods.time_var": {
        "code": "class StatsMethods:\n    def time_var(self, dtype, size):\n        self.data.var()\n\n    def setup(self, dtype, size):\n        self.data = np.ones(size, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = np.random.randn(size) + 1j * np.random.randn(size)",
        "min_run_count": 2,
        "name": "bench_core.StatsMethods.time_var",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ],
            [
                "100",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "077c5f8f3428087fe79f41d4e0cb9def513b895d7f0814c764ebfa8733e46655",
        "warmup_time": -1
    },
    "bench_core.Temporaries.time_large": {
        "code": "class Temporaries:\n    def time_large(self):\n        (self.alarge * 2) + self.blarge\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)",
        "min_run_count": 2,
        "name": "bench_core.Temporaries.time_large",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d1f17784ab0409272af0ac08b2609f381d7257185a54f102e5114b3f8548fbf3",
        "warmup_time": -1
    },
    "bench_core.Temporaries.time_large2": {
        "code": "class Temporaries:\n    def time_large2(self):\n        (self.alarge + self.blarge) - 2\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)",
        "min_run_count": 2,
        "name": "bench_core.Temporaries.time_large2",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "23dea77757706f4d1d936f725e42bdc67c57d9b2f919e4da807d26ffe127ca51",
        "warmup_time": -1
    },
    "bench_core.Temporaries.time_mid": {
        "code": "class Temporaries:\n    def time_mid(self):\n        (self.amid * 2) + self.bmid\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)",
        "min_run_count": 2,
        "name": "bench_core.Temporaries.time_mid",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ad3406f4f9a8d7ad3c489e9028cedc12079758fe89272347756b7ea6e011a267",
        "warmup_time": -1
    },
    "bench_core.Temporaries.time_mid2": {
        "code": "class Temporaries:\n    def time_mid2(self):\n        (self.amid + self.bmid) - 2\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)",
        "min_run_count": 2,
        "name": "bench_core.Temporaries.time_mid2",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5ad422ecaa9af109188d4d1fcb95cdfe8fce8d2ed999ef8a241e3af3f1677bbe",
        "warmup_time": -1
    },
    "bench_core.UnpackBits.time_unpackbits": {
        "code": "class UnpackBits:\n    def time_unpackbits(self):\n        np.unpackbits(self.d)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)",
        "min_run_count": 2,
        "name": "bench_core.UnpackBits.time_unpackbits",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8a9b8fdeeee1d01e42caff6c2cd0efc371c72053e373203f670f49c399a19ef2",
        "warmup_time": -1
    },
    "bench_core.UnpackBits.time_unpackbits_axis0": {
        "code": "class UnpackBits:\n    def time_unpackbits_axis0(self):\n        np.unpackbits(self.d2, axis=0)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)",
        "min_run_count": 2,
        "name": "bench_core.UnpackBits.time_unpackbits_axis0",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b842c713e8a843ac2273fe2f17c174ecd27b28a6dace841dac2a13d913caa8f7",
        "warmup_time": -1
    },
    "bench_core.UnpackBits.time_unpackbits_axis1": {
        "code": "class UnpackBits:\n    def time_unpackbits_axis1(self):\n        np.unpackbits(self.d2, axis=1)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)",
        "min_run_count": 2,
        "name": "bench_core.UnpackBits.time_unpackbits_axis1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7ac672e3d48251be042a8a5e4b8167dbb3b91f0af99b4f01f9d9287e7561cd73",
        "warmup_time": -1
    },
    "bench_core.UnpackBits.time_unpackbits_axis1_little": {
        "code": "class UnpackBits:\n    def time_unpackbits_axis1_little(self):\n        np.unpackbits(self.d2, bitorder=\"little\", axis=1)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)",
        "min_run_count": 2,
        "name": "bench_core.UnpackBits.time_unpackbits_axis1_little",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6449672a44b525868dbb66b244d23b3cc985ed6310b7c63a3d360091748497fa",
        "warmup_time": -1
    },
    "bench_core.UnpackBits.time_unpackbits_little": {
        "code": "class UnpackBits:\n    def time_unpackbits_little(self):\n        np.unpackbits(self.d, bitorder=\"little\")\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)",
        "min_run_count": 2,
        "name": "bench_core.UnpackBits.time_unpackbits_little",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "074fea3cb327abbd97e59f2acf3ae2eaefb70020bdef1cab122a9190ee139eb8",
        "warmup_time": -1
    },
    "bench_creation.Create.time_empty": {
        "code": "class Create:\n    def time_empty(self, shape, npdtypes):\n        np.empty(shape, dtype=npdtypes)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_empty",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "e5fda2bebd728f9c400f51df9a0324f599f769f270747e9dbcfa817c983790c9",
        "warmup_time": -1
    },
    "bench_creation.Create.time_empty_like": {
        "code": "class Create:\n    def time_empty_like(self, shape, npdtypes):\n        np.empty_like(self.xarg)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_empty_like",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "c6d8268b0326a1b38c1598a1fdde20835d385351bc7126343f37ea41e8ddf784",
        "warmup_time": -1
    },
    "bench_creation.Create.time_full": {
        "code": "class Create:\n    def time_full(self, shape, npdtypes):\n        np.full(shape, self.xarg[1], dtype=npdtypes)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_full",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "7c4d9cd8367021bb7585020e60045a729e9c69b4617d7065ae7a0607d17b332b",
        "warmup_time": -1
    },
    "bench_creation.Create.time_full_like": {
        "code": "class Create:\n    def time_full_like(self, shape, npdtypes):\n        np.full_like(self.xarg, self.xarg[0])\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_full_like",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "8f837ee75d848bac156bd5299757f8d8c9efdeecd28a867bdac16085012ccb75",
        "warmup_time": -1
    },
    "bench_creation.Create.time_ones": {
        "code": "class Create:\n    def time_ones(self, shape, npdtypes):\n        np.ones(shape, dtype=npdtypes)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_ones",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "057e577a36f694006be85773aa1142784024a8e37bd392f913f7d6ac3d4d20e5",
        "warmup_time": -1
    },
    "bench_creation.Create.time_ones_like": {
        "code": "class Create:\n    def time_ones_like(self, shape, npdtypes):\n        np.ones_like(self.xarg)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_ones_like",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "5636055b7c31df3d922bdc618c38d90e672370024fd0153eb7e20bdf85b1a2d5",
        "warmup_time": -1
    },
    "bench_creation.Create.time_zeros": {
        "code": "class Create:\n    def time_zeros(self, shape, npdtypes):\n        np.zeros(shape, dtype=npdtypes)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_zeros",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "b1d4ac3295fb927cb5a2966d2e0c067334fd173bd6df38af58d8a27f4515703c",
        "warmup_time": -1
    },
    "bench_creation.Create.time_zeros_like": {
        "code": "class Create:\n    def time_zeros_like(self, shape, npdtypes):\n        np.zeros_like(self.xarg)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.Create.time_zeros_like",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "512",
                "(32, 32)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "215221138a7dbf75df37eb76379da7a204843b57865804a43078ee5efb344e40",
        "warmup_time": -1
    },
    "bench_creation.MeshGrid.time_meshgrid": {
        "code": "class MeshGrid:\n    def time_meshgrid(self, size, ndims, ind, ndtype):\n        np.meshgrid(*self.grid_dims, indexing=ind)\n\n    def setup(self, size, ndims, ind, ndtype):\n        rnd = np.random.RandomState(1864768776)\n        self.grid_dims = [(rnd.random_sample(size)).astype(ndtype) for\n                          x in range(ndims)]",
        "min_run_count": 2,
        "name": "bench_creation.MeshGrid.time_meshgrid",
        "number": 0,
        "param_names": [
            "size",
            "ndims",
            "ind",
            "ndtype"
        ],
        "params": [
            [
                "16",
                "32"
            ],
            [
                "2",
                "3",
                "4"
            ],
            [
                "'ij'",
                "'xy'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "757f3383828d2c386961fbabc61f14624f237e64595f47c26781138bc20a05b2",
        "warmup_time": -1
    },
    "bench_creation.UfuncsFromDLP.time_from_dlpack": {
        "code": "class UfuncsFromDLP:\n    def time_from_dlpack(self, shape, npdtypes):\n        np.from_dlpack(self.xarg)\n\n    def setup(self, shape, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_creation.UfuncsFromDLP.time_from_dlpack",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "16",
                "32",
                "(16, 16)",
                "(64, 64)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "61237f2d90507b8ae10df3a3b2490cbd982024a487f26b7215bfbba903f8f68c",
        "warmup_time": -1
    },
    "bench_function_base.Bincount.time_bincount": {
        "code": "class Bincount:\n    def time_bincount(self):\n        np.bincount(self.d)\n\n    def setup(self):\n        self.d = np.arange(80000, dtype=np.intp)\n        self.e = self.d.astype(np.float64)",
        "min_run_count": 2,
        "name": "bench_function_base.Bincount.time_bincount",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5d90f434eae543f580a5bb7f86e14c4663521f721b5a056155c61223dec781e4",
        "warmup_time": -1
    },
    "bench_function_base.Bincount.time_weights": {
        "code": "class Bincount:\n    def time_weights(self):\n        np.bincount(self.d, weights=self.e)\n\n    def setup(self):\n        self.d = np.arange(80000, dtype=np.intp)\n        self.e = self.d.astype(np.float64)",
        "min_run_count": 2,
        "name": "bench_function_base.Bincount.time_weights",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "21806334def6c126f9bb25e7ed2a2e4d9be995f373cd288727bb4d8e33bb11cb",
        "warmup_time": -1
    },
    "bench_function_base.Histogram1D.time_fine_binning": {
        "code": "class Histogram1D:\n    def time_fine_binning(self):\n        np.histogram(self.d, 10000, (0, 100))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram1D.time_fine_binning",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fd9a7cd0ee34b75f9eddd8c022b58b149397c82b4bd22de6fdb8b6e23c72e19c",
        "warmup_time": -1
    },
    "bench_function_base.Histogram1D.time_full_coverage": {
        "code": "class Histogram1D:\n    def time_full_coverage(self):\n        np.histogram(self.d, 200, (0, 100))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram1D.time_full_coverage",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7a6b3163b94451004a6b27ea9f14f9aa6c0e86e437074c1558a53ad422af141a",
        "warmup_time": -1
    },
    "bench_function_base.Histogram1D.time_small_coverage": {
        "code": "class Histogram1D:\n    def time_small_coverage(self):\n        np.histogram(self.d, 200, (50, 51))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram1D.time_small_coverage",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "324b8676b5ae4c324e05671ffe2058af996d3cb540d845b6701cbae68eb26d99",
        "warmup_time": -1
    },
    "bench_function_base.Histogram2D.time_fine_binning": {
        "code": "class Histogram2D:\n    def time_fine_binning(self):\n        np.histogramdd(self.d, (10000, 10000), ((0, 100), (0, 100)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram2D.time_fine_binning",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2f6f1c99fb221c95e8526dc863c8b1e72546468bf162e20e62539f171241ceae",
        "warmup_time": -1
    },
    "bench_function_base.Histogram2D.time_full_coverage": {
        "code": "class Histogram2D:\n    def time_full_coverage(self):\n        np.histogramdd(self.d, (200, 200), ((0, 100), (0, 100)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram2D.time_full_coverage",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "79d7122f11109af1751f17c3a36c5df88fa3cbb842d49a9859528c7ea37eaf4f",
        "warmup_time": -1
    },
    "bench_function_base.Histogram2D.time_small_coverage": {
        "code": "class Histogram2D:\n    def time_small_coverage(self):\n        np.histogramdd(self.d, (200, 200), ((50, 51), (50, 51)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))",
        "min_run_count": 2,
        "name": "bench_function_base.Histogram2D.time_small_coverage",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e8ff2855bc11b18b68832bbd0917468aab6b272a86ec5cf2fd1ac46d3e39adf5",
        "warmup_time": -1
    },
    "bench_function_base.Linspace.time_linspace_array": {
        "code": "class Linspace:\n    def time_linspace_array(self):\n        np.linspace(self.d, 10, 10)\n\n    def setup(self):\n        self.d = np.array([1, 2, 3])",
        "min_run_count": 2,
        "name": "bench_function_base.Linspace.time_linspace_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "57b4f4afbd30dad37d722535cb96d47814371aae36f9741ef0bbdbcbbaebbb46",
        "warmup_time": -1
    },
    "bench_function_base.Linspace.time_linspace_scalar": {
        "code": "class Linspace:\n    def time_linspace_scalar(self):\n        np.linspace(0, 10, 2)\n\n    def setup(self):\n        self.d = np.array([1, 2, 3])",
        "min_run_count": 2,
        "name": "bench_function_base.Linspace.time_linspace_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "218e16d138735dfe5dbdb5a236e56828262bd70df1bc989156dcec0083b9ffd5",
        "warmup_time": -1
    },
    "bench_function_base.Mean.time_mean": {
        "code": "class Mean:\n    def time_mean(self, size):\n        np.mean(self.array)\n\n    def setup(self, size):\n        self.array = np.arange(2*size).reshape(2, size)",
        "min_run_count": 2,
        "name": "bench_function_base.Mean.time_mean",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9806666f70037d09e27ef0b2f913b58de154149c5adc3f1ba930288d1a95890a",
        "warmup_time": -1
    },
    "bench_function_base.Mean.time_mean_axis": {
        "code": "class Mean:\n    def time_mean_axis(self, size):\n        np.mean(self.array, axis=1)\n\n    def setup(self, size):\n        self.array = np.arange(2*size).reshape(2, size)",
        "min_run_count": 2,
        "name": "bench_function_base.Mean.time_mean_axis",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "48f7840dd4a24e2077ecef160e67ad5b3e182769b1445ec3f482e5cf86d2569e",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_even": {
        "code": "class Median:\n    def time_even(self):\n        np.median(self.e)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_even",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "13b3b69fccb37edf9506bbda2fc94d186da8c807a7b327a06594a505019f2f2f",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_even_inplace": {
        "code": "class Median:\n    def time_even_inplace(self):\n        np.median(self.e, overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_even_inplace",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "66ab8767b044f8bba391dcde907bc3f8adaaa5ed6d3bdc98f8cd145c3d1504dc",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_even_small": {
        "code": "class Median:\n    def time_even_small(self):\n        np.median(self.e[:500], overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_even_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7e875480f5efc782650ad82c3da3b98e1c792c1a0ef6909b6f4ca34723f5f74a",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_odd": {
        "code": "class Median:\n    def time_odd(self):\n        np.median(self.o)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_odd",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c9387484b60ca2a29af6a76b204e2e946707a510ce8f0cf34ad94034e60fa9f4",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_odd_inplace": {
        "code": "class Median:\n    def time_odd_inplace(self):\n        np.median(self.o, overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_odd_inplace",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "247fb9cabd1120f968f253104e257b12ee43dfdccd615442560ee3fc19c73f19",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_odd_small": {
        "code": "class Median:\n    def time_odd_small(self):\n        np.median(self.o[:500], overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_odd_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ca5ae3c9b420da70652d3804e6ed8c638ebce887f7e8bf1ea47eeeac067f0dc5",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_tall": {
        "code": "class Median:\n    def time_tall(self):\n        np.median(self.tall, axis=-1)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_tall",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cdd4fd8c870b9317004bded6790f3ee97e061fda9c111d1ff931f73a65f45800",
        "warmup_time": -1
    },
    "bench_function_base.Median.time_wide": {
        "code": "class Median:\n    def time_wide(self):\n        np.median(self.wide, axis=0)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))",
        "min_run_count": 2,
        "name": "bench_function_base.Median.time_wide",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2cc4f8b970b0002377700dcbd509c1ee53cb30b8ce8e3703b2a50af674db3d4d",
        "warmup_time": -1
    },
    "bench_function_base.Partition.time_argpartition": {
        "code": "class Partition:\n    def time_argpartition(self, dtype, array_type, k):\n        temp = np.argpartition(self.arr, k)\n\n    def setup(self, dtype, array_type, k):\n        rnd = np.random.seed(2136297818)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(\n            self.ARRAY_SIZE, dtype, *array_type[1:], rnd)",
        "min_run_count": 2,
        "name": "bench_function_base.Partition.time_argpartition",
        "number": 0,
        "param_names": [
            "dtype",
            "array_type",
            "k"
        ],
        "params": [
            [
                "'float64'",
                "'int64'",
                "'float32'",
                "'int32'",
                "'int16'",
                "'float16'"
            ],
            [
                "('random',)",
                "('ordered',)",
                "('reversed',)",
                "('uniform',)",
                "('sorted_block', 10)",
                "('sorted_block', 100)",
                "('sorted_block', 1000)"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "140296e64c81b3786f008b92a184e76a0389211fc007d6d1b6859b7f0545efc2",
        "warmup_time": -1
    },
    "bench_function_base.Partition.time_partition": {
        "code": "class Partition:\n    def time_partition(self, dtype, array_type, k):\n        temp = np.partition(self.arr, k)\n\n    def setup(self, dtype, array_type, k):\n        rnd = np.random.seed(2136297818)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(\n            self.ARRAY_SIZE, dtype, *array_type[1:], rnd)",
        "min_run_count": 2,
        "name": "bench_function_base.Partition.time_partition",
        "number": 0,
        "param_names": [
            "dtype",
            "array_type",
            "k"
        ],
        "params": [
            [
                "'float64'",
                "'int64'",
                "'float32'",
                "'int32'",
                "'int16'",
                "'float16'"
            ],
            [
                "('random',)",
                "('ordered',)",
                "('reversed',)",
                "('uniform',)",
                "('sorted_block', 10)",
                "('sorted_block', 100)",
                "('sorted_block', 1000)"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "974b9a3d83122701948bd235466afbf485aca2494b14eee7f1f69753fe5b859f",
        "warmup_time": -1
    },
    "bench_function_base.Percentile.time_percentile": {
        "code": "class Percentile:\n    def time_percentile(self):\n        np.percentile(self.e, [25, 35, 55, 65, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)",
        "min_run_count": 2,
        "name": "bench_function_base.Percentile.time_percentile",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f5bf2ff405d84895a820e0a9c9f2435f5b989d3c317e9e5c736d92cebb339eee",
        "warmup_time": -1
    },
    "bench_function_base.Percentile.time_percentile_small": {
        "code": "class Percentile:\n    def time_percentile_small(self):\n        np.percentile(self.o, [25, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)",
        "min_run_count": 2,
        "name": "bench_function_base.Percentile.time_percentile_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "78f7977cc6db145459abc795273ceb862115cf2eb50ebe09caef0b0dea19be6f",
        "warmup_time": -1
    },
    "bench_function_base.Percentile.time_quartile": {
        "code": "class Percentile:\n    def time_quartile(self):\n        np.percentile(self.e, [25, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)",
        "min_run_count": 2,
        "name": "bench_function_base.Percentile.time_quartile",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "766b2fd824cb705705ac99667737eb621cd8106bcf8b696ac89d12f20ac47474",
        "warmup_time": -1
    },
    "bench_function_base.Select.time_select": {
        "code": "class Select:\n    def time_select(self):\n        np.select(self.cond, [self.d, self.e])\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = [(self.d > 4), (self.d < 2)]\n        self.cond_large = [(self.d > 4), (self.d < 2)] * 10",
        "min_run_count": 2,
        "name": "bench_function_base.Select.time_select",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "89f02a048ace03b6c3269e61811da1ece2dab2a456536225dafaccbc385920a7",
        "warmup_time": -1
    },
    "bench_function_base.Select.time_select_larger": {
        "code": "class Select:\n    def time_select_larger(self):\n        np.select(self.cond_large, ([self.d, self.e] * 10))\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = [(self.d > 4), (self.d < 2)]\n        self.cond_large = [(self.d > 4), (self.d < 2)] * 10",
        "min_run_count": 2,
        "name": "bench_function_base.Select.time_select_larger",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a702e09750946268c44bce105934f13f28b8abe05f71a1f660e967804fafd305",
        "warmup_time": -1
    },
    "bench_function_base.Sort.time_argsort": {
        "code": "class Sort:\n    def time_argsort(self, kind, dtype, array_type):\n        np.argsort(self.arr, kind=kind)\n\n    def setup(self, kind, dtype, array_type):\n        rnd = np.random.RandomState(507582308)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(self.ARRAY_SIZE, dtype, *array_type[1:], rnd)",
        "min_run_count": 2,
        "name": "bench_function_base.Sort.time_argsort",
        "number": 0,
        "param_names": [
            "kind",
            "dtype",
            "array_type"
        ],
        "params": [
            [
                "'quick'",
                "'merge'",
                "'heap'"
            ],
            [
                "'float64'",
                "'int64'",
                "'float32'",
                "'uint32'",
                "'int32'",
                "'int16'",
                "'float16'"
            ],
            [
                "('random',)",
                "('ordered',)",
                "('reversed',)",
                "('uniform',)",
                "('sorted_block', 10)",
                "('sorted_block', 100)",
                "('sorted_block', 1000)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "965f008f6b2a5979574ec70078caeead1652d3815e7ef3cebba41b08eb0b94dd",
        "warmup_time": -1
    },
    "bench_function_base.Sort.time_sort": {
        "code": "class Sort:\n    def time_sort(self, kind, dtype, array_type):\n        # Using np.sort(...) instead of arr.sort(...) because it makes a copy.\n        # This is important because the data is prepared once per benchmark, but\n        # used across multiple runs.\n        np.sort(self.arr, kind=kind)\n\n    def setup(self, kind, dtype, array_type):\n        rnd = np.random.RandomState(507582308)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(self.ARRAY_SIZE, dtype, *array_type[1:], rnd)",
        "min_run_count": 2,
        "name": "bench_function_base.Sort.time_sort",
        "number": 0,
        "param_names": [
            "kind",
            "dtype",
            "array_type"
        ],
        "params": [
            [
                "'quick'",
                "'merge'",
                "'heap'"
            ],
            [
                "'float64'",
                "'int64'",
                "'float32'",
                "'uint32'",
                "'int32'",
                "'int16'",
                "'float16'"
            ],
            [
                "('random',)",
                "('ordered',)",
                "('reversed',)",
                "('uniform',)",
                "('sorted_block', 10)",
                "('sorted_block', 100)",
                "('sorted_block', 1000)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c0650a31f43c82f857fe85d1d392c7851ee82d1afc8a0cb0d0a278e4d8ba435b",
        "warmup_time": -1
    },
    "bench_function_base.Sort.time_sort_worst": {
        "code": "class SortWorst:\n    def time_sort_worst(self):\n        np.sort(self.worst)\n\n    def setup(self):\n        # quicksort median of 3 worst case\n        self.worst = np.arange(1000000)\n        x = self.worst\n        while x.size > 3:\n            mid = x.size // 2\n            x[mid], x[-2] = x[-2], x[mid]\n            x = x[:-2]",
        "min_run_count": 2,
        "name": "bench_function_base.Sort.time_sort_worst",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ace32d23c7f67f08c3993d54ad4d4b67cd9b56a42a8b95f830141cce64e1d6ec",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_1": {
        "code": "class Where:\n    def time_1(self):\n        np.where(self.cond)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2dd47a7b8e0cefb351dab898bfe49d3385cef1736a5a9aa51db529c7e338c8c1",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_2": {
        "code": "class Where:\n    def time_2(self):\n        np.where(self.cond, self.d, self.e)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_2",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9457e2084780eabaaec5fa9a1a4b0d1dce0ba011aad7d7835c1c22eb34209085",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_2_broadcast": {
        "code": "class Where:\n    def time_2_broadcast(self):\n        np.where(self.cond, self.d, 0)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_2_broadcast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c1301598fcf3aa42ddf77f171148c89737e74c7990d8f10e7cff4a980989aa2d",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_2_object": {
        "code": "class Where:\n    def time_2_object(self):\n        # object and byteswapped arrays have a\n        # special slow path in the where internals\n        np.where(self.cond, self.d_o, self.e_o)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_2_object",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "574f3de6ed3ed44ede56c99cfc2d5cf936d4c7c95f1a9add3874161be248c849",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_all_ones": {
        "code": "class Where:\n    def time_all_ones(self):\n        np.where(self.all_ones)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_all_ones",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cce8e2ac1f76e5b17b65402016d73fc57f948ec6ca5099b6c56e24f468481055",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_all_zeros": {
        "code": "class Where:\n    def time_all_zeros(self):\n        np.where(self.all_zeros)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_all_zeros",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4fdaa7369681d1f655e46e368d60d6366f5dd9ad030844d3271d5b7fbf0ba502",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_ones_x2": {
        "code": "class Where:\n    def time_interleaved_ones_x2(self):\n        np.where(self.rep_ones_2)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_ones_x2",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "65fbf2363dffbb370a33cd75b4076ecae202850ed43d8c2ba320a915df7f2862",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_ones_x4": {
        "code": "class Where:\n    def time_interleaved_ones_x4(self):\n        np.where(self.rep_ones_4)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_ones_x4",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4a1f15f25ac6a0ffd954ea8e1b24613378e0ccdd71b6d42227d7313aee2cbefa",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_ones_x8": {
        "code": "class Where:\n    def time_interleaved_ones_x8(self):\n        np.where(self.rep_ones_8)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_ones_x8",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bef8ea628507ea2832681a5d7d84e2157cdf487ee894024711c5f3a1d1315fc9",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_zeros_x2": {
        "code": "class Where:\n    def time_interleaved_zeros_x2(self):\n        np.where(self.rep_zeros_2)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_zeros_x2",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f193b86e46a1c7c0868828220c470dd23161eed5b70e3a39311b960e5613fef6",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_zeros_x4": {
        "code": "class Where:\n    def time_interleaved_zeros_x4(self):\n        np.where(self.rep_zeros_4)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_zeros_x4",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "76f2972357c38a3639eaf6880dff39d64028ec7cdcce64528a9d28124ecf8363",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_interleaved_zeros_x8": {
        "code": "class Where:\n    def time_interleaved_zeros_x8(self):\n        np.where(self.rep_zeros_8)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_interleaved_zeros_x8",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5be86eacab067d39fe48ea595b4f2eabfa22587591c76a2547d6a1c3cd617223",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_random_01_percent": {
        "code": "class Where:\n    def time_random_01_percent(self):\n        np.where(self.rand_cond_01)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_random_01_percent",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1bee931b698dc781ba65b7a73f58d88a4b3f06e2d2f219a37788cd1dbec97640",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_random_20_percent": {
        "code": "class Where:\n    def time_random_20_percent(self):\n        np.where(self.rand_cond_20)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_random_20_percent",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "961497c6ecc0871fe06cc4abfebb14076699ed7bda1591f870b04c551da4a278",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_random_30_percent": {
        "code": "class Where:\n    def time_random_30_percent(self):\n        np.where(self.rand_cond_30)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_random_30_percent",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "db1a57dfd6b9de906fa23844d3b021a68bab0a39a1b134d0ead0811134c421a8",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_random_40_percent": {
        "code": "class Where:\n    def time_random_40_percent(self):\n        np.where(self.rand_cond_40)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_random_40_percent",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "06e24b0bff857b70f16a619fb0f5d946b5d57945d8055b525deb112debcb5bcf",
        "warmup_time": -1
    },
    "bench_function_base.Where.time_random_50_percent": {
        "code": "class Where:\n    def time_random_50_percent(self):\n        np.where(self.rand_cond_50)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.d_o = self.d.astype(object)\n        self.e = self.d.copy()\n        self.e_o = self.d_o.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0",
        "min_run_count": 2,
        "name": "bench_function_base.Where.time_random_50_percent",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b559658104b7db09d7324d0f9ee4ef3c6c55fe9b4b19acaed4f208e72dfd48e2",
        "warmup_time": -1
    },
    "bench_import.Import.time_fft": {
        "code": "class Import:\n    def time_fft(self):\n        self.execute('from numpy import fft')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_fft",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "032a4b610918503dbb969cc5837be23961652784b6221173d38fa901e9811532",
        "warmup_time": -1
    },
    "bench_import.Import.time_linalg": {
        "code": "class Import:\n    def time_linalg(self):\n        self.execute('from numpy import linalg')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_linalg",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c39a1494b3509e08cf7735c691b237b7bea72c7ab9acc811567991c16104f2aa",
        "warmup_time": -1
    },
    "bench_import.Import.time_ma": {
        "code": "class Import:\n    def time_ma(self):\n        self.execute('from numpy import ma')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_ma",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8a42f579234af8dd0de6c97e2456192925e2089772dc64143802bc3d511757e1",
        "warmup_time": -1
    },
    "bench_import.Import.time_matlib": {
        "code": "class Import:\n    def time_matlib(self):\n        self.execute('from numpy import matlib')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_matlib",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1646af4cf76933a57faea27e4294eb5bacd6fa5fa3eb86f10e9e3f8db9a2cd57",
        "warmup_time": -1
    },
    "bench_import.Import.time_numpy": {
        "code": "class Import:\n    def time_numpy(self):\n        self.execute('import numpy')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_numpy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5cb9a60ea63951e4ed5e53d18cbebb7b1ae313ae422ff739356454e6f9f2c5d7",
        "warmup_time": -1
    },
    "bench_import.Import.time_numpy_inspect": {
        "code": "class Import:\n    def time_numpy_inspect(self):\n        # What are the savings from avoiding to import the inspect module?\n        self.execute('import numpy, inspect')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_numpy_inspect",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3dd22ba8c1d5c49a9d99843d70d69a23add5d539d482ece58b85fe9cbfae98d2",
        "warmup_time": -1
    },
    "bench_import.Import.time_random": {
        "code": "class Import:\n    def time_random(self):\n        self.execute('from numpy import random')",
        "min_run_count": 2,
        "name": "bench_import.Import.time_random",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "93e927c190a453a13a4dc57e51ad273e11e681bf788ef4051cf0b3a255837552",
        "warmup_time": -1
    },
    "bench_indexing.FlatIterIndexing.time_flat_bool_index_all": {
        "code": "class FlatIterIndexing:\n    def time_flat_bool_index_all(self):\n        self.a.flat[self.m_all]\n\n    def setup(self):\n        self.a = np.ones((200, 50000))\n        self.m_all = np.repeat(True, 200 * 50000)\n        self.m_half = np.copy(self.m_all)\n        self.m_half[::2] = False\n        self.m_none = np.repeat(False, 200 * 50000)",
        "min_run_count": 2,
        "name": "bench_indexing.FlatIterIndexing.time_flat_bool_index_all",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e8e7b7d722421a722a18f2a795f74f04eb9f61ceeda33616f80b251afab1cc89",
        "warmup_time": -1
    },
    "bench_indexing.FlatIterIndexing.time_flat_bool_index_half": {
        "code": "class FlatIterIndexing:\n    def time_flat_bool_index_half(self):\n        self.a.flat[self.m_half]\n\n    def setup(self):\n        self.a = np.ones((200, 50000))\n        self.m_all = np.repeat(True, 200 * 50000)\n        self.m_half = np.copy(self.m_all)\n        self.m_half[::2] = False\n        self.m_none = np.repeat(False, 200 * 50000)",
        "min_run_count": 2,
        "name": "bench_indexing.FlatIterIndexing.time_flat_bool_index_half",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e519ac1b9c0589cfa7889e177d2113db1373ab193525979fd3ced980642312c7",
        "warmup_time": -1
    },
    "bench_indexing.FlatIterIndexing.time_flat_bool_index_none": {
        "code": "class FlatIterIndexing:\n    def time_flat_bool_index_none(self):\n        self.a.flat[self.m_none]\n\n    def setup(self):\n        self.a = np.ones((200, 50000))\n        self.m_all = np.repeat(True, 200 * 50000)\n        self.m_half = np.copy(self.m_all)\n        self.m_half[::2] = False\n        self.m_none = np.repeat(False, 200 * 50000)",
        "min_run_count": 2,
        "name": "bench_indexing.FlatIterIndexing.time_flat_bool_index_none",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d7be79fa5d9b27c80784d38aedce054f5af9beeb4f4492baf69f09948cadb728",
        "warmup_time": -1
    },
    "bench_indexing.Indexing.time_op": {
        "code": "class Indexing:\n    def time_op(self, dtype, indexes, sel, op):\n        self.func()\n\n    def setup(self, dtype, indexes, sel, op):\n        sel = sel.replace('I', indexes)\n    \n        ns = {'a': get_square_(dtype),\n              'np': np,\n              'indexes_': get_indexes_(),\n              'indexes_rand_': get_indexes_rand_()}\n    \n        code = \"def run():\\n    a[%s]%s\"\n        code = code % (sel, op)\n    \n        exec(code, ns)\n        self.func = ns['run']",
        "min_run_count": 2,
        "name": "bench_indexing.Indexing.time_op",
        "number": 0,
        "param_names": [
            "dtype",
            "indexes",
            "sel",
            "op"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'object'",
                "'O,i'"
            ],
            [
                "'indexes_'",
                "'indexes_rand_'"
            ],
            [
                "'I'",
                "':,I'",
                "'np.ix_(I, I)'"
            ],
            [
                "''",
                "'=1'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a5cda688f2bd51416640bb296d23a2b6593c5d5771330ab1c0a7ff71a6fece6e",
        "warmup_time": -1
    },
    "bench_indexing.IndexingSeparate.time_mmap_fancy_indexing": {
        "code": "class IndexingSeparate:\n    def time_mmap_fancy_indexing(self):\n        for i in range(1000):\n            self.fp[self.indexes]\n\n    def setup(self):\n        self.tmp_dir = mkdtemp()\n        self.fp = memmap(pjoin(self.tmp_dir, 'tmp.dat'),\n                         dtype=float32, mode='w+', shape=(50, 60))\n        self.indexes = array([3, 4, 6, 10, 20])",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingSeparate.time_mmap_fancy_indexing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d511fabf6c9d75bca8e0c77070a292a7498f23fd253bf151c2d0472028c8e375",
        "warmup_time": -1
    },
    "bench_indexing.IndexingSeparate.time_mmap_slicing": {
        "code": "class IndexingSeparate:\n    def time_mmap_slicing(self):\n        for i in range(1000):\n            self.fp[5:10]\n\n    def setup(self):\n        self.tmp_dir = mkdtemp()\n        self.fp = memmap(pjoin(self.tmp_dir, 'tmp.dat'),\n                         dtype=float32, mode='w+', shape=(50, 60))\n        self.indexes = array([3, 4, 6, 10, 20])",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingSeparate.time_mmap_slicing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8aac8af758ba563381c8d021d9163a34a1652b3fcc129ec3555e9221a785b469",
        "warmup_time": -1
    },
    "bench_indexing.IndexingStructured0D.time_array_all": {
        "code": "class IndexingStructured0D:\n    def time_array_all(self):\n        self.B['a'] = self.A['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingStructured0D.time_array_all",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "972e93e84611a6e63b6d9fe5d2019b3b54f98452ed2b237b58f4d58bbde4072b",
        "warmup_time": -1
    },
    "bench_indexing.IndexingStructured0D.time_array_slice": {
        "code": "class IndexingStructured0D:\n    def time_array_slice(self):\n        self.B['a'][:] = self.A['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingStructured0D.time_array_slice",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7884c48afe99676d42705373c0678163cd9358c0af75b3888566a78b64b1a0ae",
        "warmup_time": -1
    },
    "bench_indexing.IndexingStructured0D.time_scalar_all": {
        "code": "class IndexingStructured0D:\n    def time_scalar_all(self):\n        self.b['a'] = self.a['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingStructured0D.time_scalar_all",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3379d09fc19f9b870f4e9a930bc98b6cda21f792cfb9caf37992752c1ed04c9e",
        "warmup_time": -1
    },
    "bench_indexing.IndexingStructured0D.time_scalar_slice": {
        "code": "class IndexingStructured0D:\n    def time_scalar_slice(self):\n        self.b['a'][:] = self.a['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingStructured0D.time_scalar_slice",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ffcfe894af4580d854b9e8b2d38687ab9ee9c372cc0d50fd467e5eab42e974ce",
        "warmup_time": -1
    },
    "bench_indexing.IndexingWith1DArr.time_getitem_ordered": {
        "code": "class IndexingWith1DArr:\n    def time_getitem_ordered(self, shape, dtype):\n        self.arr[self.index]\n\n    def setup(self, shape, dtype):\n        self.arr = np.ones(shape, dtype)\n        self.index = np.arange(1000)\n        # index the second dimension:\n        if len(shape) == 3:\n            self.index = (slice(None), self.index)",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingWith1DArr.time_getitem_ordered",
        "number": 0,
        "param_names": [
            "shape",
            "dtype"
        ],
        "params": [
            [
                "(1000,)",
                "(1000, 1)",
                "(1000, 2)",
                "(2, 1000, 1)",
                "(1000, 3)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9299c1817ca86ae431de43cc1a1d463b86c23594610c3a9911de4e0839058da2",
        "warmup_time": -1
    },
    "bench_indexing.IndexingWith1DArr.time_setitem_ordered": {
        "code": "class IndexingWith1DArr:\n    def time_setitem_ordered(self, shape, dtype):\n        self.arr[self.index] = 0\n\n    def setup(self, shape, dtype):\n        self.arr = np.ones(shape, dtype)\n        self.index = np.arange(1000)\n        # index the second dimension:\n        if len(shape) == 3:\n            self.index = (slice(None), self.index)",
        "min_run_count": 2,
        "name": "bench_indexing.IndexingWith1DArr.time_setitem_ordered",
        "number": 0,
        "param_names": [
            "shape",
            "dtype"
        ],
        "params": [
            [
                "(1000,)",
                "(1000, 1)",
                "(1000, 2)",
                "(2, 1000, 1)",
                "(1000, 3)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "43863b59fdfd5cba758fe4f9301b302b3bafa4eab6bd3c4559f3f8666dc53731",
        "warmup_time": -1
    },
    "bench_indexing.ScalarIndexing.time_assign": {
        "code": "class ScalarIndexing:\n    def time_assign(self, ndim):\n        # time assignment from a python scalar\n        arr = self.array\n        indx = (1,) * ndim\n        for i in range(100):\n            arr[indx] = 5.\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)",
        "min_run_count": 2,
        "name": "bench_indexing.ScalarIndexing.time_assign",
        "number": 0,
        "param_names": [
            "ndim"
        ],
        "params": [
            [
                "0",
                "1",
                "2"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "52c0dfa579d132ce77b2ca2d0b042734f9d8f60d0e16ef2af7f292e1d49d5936",
        "warmup_time": -1
    },
    "bench_indexing.ScalarIndexing.time_assign_cast": {
        "code": "class ScalarIndexing:\n    def time_assign_cast(self, ndim):\n        # time an assignment which may use a cast operation\n        arr = self.array\n        indx = (1,) * ndim\n        val = np.int16(43)\n        for i in range(100):\n            arr[indx] = val\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)",
        "min_run_count": 2,
        "name": "bench_indexing.ScalarIndexing.time_assign_cast",
        "number": 0,
        "param_names": [
            "ndim"
        ],
        "params": [
            [
                "0",
                "1",
                "2"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "36f3c671c5ba3cb5633f4a6b4e211938c2eb5857440c2a0e3c06281d2c0a5bc7",
        "warmup_time": -1
    },
    "bench_indexing.ScalarIndexing.time_index": {
        "code": "class ScalarIndexing:\n    def time_index(self, ndim):\n        # time indexing.\n        arr = self.array\n        indx = (1,) * ndim\n        for i in range(100):\n            arr[indx]\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)",
        "min_run_count": 2,
        "name": "bench_indexing.ScalarIndexing.time_index",
        "number": 0,
        "param_names": [
            "ndim"
        ],
        "params": [
            [
                "0",
                "1",
                "2"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b5a4c10e3553e7101b7fc679cb355150c5b27d7c7b5544f50660fbe581936f73",
        "warmup_time": -1
    },
    "bench_io.Copy.time_cont_assign": {
        "code": "class Copy:\n    def time_cont_assign(self, typename):\n        self.d[...] = 1\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_io.Copy.time_cont_assign",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int8'",
                "'int16'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "afe3edcb5a646c1dd3efa7d2b5084f3759d877cec053e46705ac093e8bafbddd",
        "warmup_time": -1
    },
    "bench_io.Copy.time_memcpy": {
        "code": "class Copy:\n    def time_memcpy(self, typename):\n        self.d[...] = self.e_d\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_io.Copy.time_memcpy",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int8'",
                "'int16'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8e4099e96ab5221807bc0dd397733a0016f6f1bbbca8f5b800a8249a6e72bc7e",
        "warmup_time": -1
    },
    "bench_io.Copy.time_memcpy_large_out_of_place": {
        "code": "class Copy:\n    def time_memcpy_large_out_of_place(self, typename):\n        l = np.ones(1024**2, dtype=np.dtype(typename))\n        l.copy()\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_io.Copy.time_memcpy_large_out_of_place",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int8'",
                "'int16'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "862a7ab3e90582f36eae4004c8ed717e47fc8e8fa042cf49b6c12a5df1d6b4c7",
        "warmup_time": -1
    },
    "bench_io.Copy.time_strided_assign": {
        "code": "class Copy:\n    def time_strided_assign(self, typename):\n        self.dflat[::2] = 2\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_io.Copy.time_strided_assign",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int8'",
                "'int16'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "61d585e17292b3b6a8aba7775561f3fbffe991d8655b2335bfdbf1c83de99915",
        "warmup_time": -1
    },
    "bench_io.Copy.time_strided_copy": {
        "code": "class Copy:\n    def time_strided_copy(self, typename):\n        self.d[...] = self.e.T\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_io.Copy.time_strided_copy",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int8'",
                "'int16'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e431dccc9dca8066e5245473c4aa724314bd94e7a7a5db466deb0e5cfcfab482",
        "warmup_time": -1
    },
    "bench_io.CopyTo.time_copyto": {
        "code": "class CopyTo:\n    def time_copyto(self):\n        np.copyto(self.d, self.e)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)",
        "min_run_count": 2,
        "name": "bench_io.CopyTo.time_copyto",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "07950888132a0948b3c041b33f0f183b09ef914213babe934461be9b316d3221",
        "warmup_time": -1
    },
    "bench_io.CopyTo.time_copyto_8_dense": {
        "code": "class CopyTo:\n    def time_copyto_8_dense(self):\n        np.copyto(self.d, self.e, where=self.im8)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)",
        "min_run_count": 2,
        "name": "bench_io.CopyTo.time_copyto_8_dense",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a73b9cc35e00d11b5cd0365076a62b7e2e3058a742abdac1ff0632af2afa63ce",
        "warmup_time": -1
    },
    "bench_io.CopyTo.time_copyto_8_sparse": {
        "code": "class CopyTo:\n    def time_copyto_8_sparse(self):\n        np.copyto(self.d, self.e, where=self.m8)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)",
        "min_run_count": 2,
        "name": "bench_io.CopyTo.time_copyto_8_sparse",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6b3380a508d21032c997a83cb0f5f88e055d7c440b0e802e3856e0bba7b42699",
        "warmup_time": -1
    },
    "bench_io.CopyTo.time_copyto_dense": {
        "code": "class CopyTo:\n    def time_copyto_dense(self):\n        np.copyto(self.d, self.e, where=self.im)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)",
        "min_run_count": 2,
        "name": "bench_io.CopyTo.time_copyto_dense",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3fc8f0ec8a3cbc2c0e6efed89c18560d81b4f3055eedac3e4cc6fb8f0ea88b6f",
        "warmup_time": -1
    },
    "bench_io.CopyTo.time_copyto_sparse": {
        "code": "class CopyTo:\n    def time_copyto_sparse(self):\n        np.copyto(self.d, self.e, where=self.m)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)",
        "min_run_count": 2,
        "name": "bench_io.CopyTo.time_copyto_sparse",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8b3edb57c11fe88b4cb32c4a592531aad95d8749f99cdaa508ad926e7411faf0",
        "warmup_time": -1
    },
    "bench_io.LoadNpyOverhead.time_loadnpy_overhead": {
        "code": "class LoadNpyOverhead:\n    def time_loadnpy_overhead(self):\n        self.buffer.seek(0, SEEK_SET)\n        np.load(self.buffer)\n\n    def setup(self):\n        self.buffer = BytesIO()\n        np.save(self.buffer, get_squares_()['float32'])",
        "min_run_count": 2,
        "name": "bench_io.LoadNpyOverhead.time_loadnpy_overhead",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6b84e0b6410e3875e09574c579165d8c650f2eac1c1f39a7f86c32f49d3a0968",
        "warmup_time": -1
    },
    "bench_io.LoadtxtCSVComments.time_comment_loadtxt_csv": {
        "code": "class LoadtxtCSVComments:\n    def time_comment_loadtxt_csv(self, num_lines):\n        # benchmark handling of lines with comments\n        # when loading in from csv files\n    \n        # inspired by similar benchmark in pandas\n        # for read_csv\n    \n        # need to rewind StringIO object (unfortunately\n        # confounding timing result somewhat) for every\n        # call to timing test proper\n        np.loadtxt(self.data_comments,\n                   delimiter=',')\n        self.data_comments.seek(0)\n\n    def setup(self, num_lines):\n        data = ['1,2,3 # comment'] * num_lines\n        # unfortunately, timeit will only run setup()\n        # between repeat events, but not for iterations\n        # within repeats, so the StringIO object\n        # will have to be rewinded in the benchmark proper\n        self.data_comments = StringIO('\\n'.join(data))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtCSVComments.time_comment_loadtxt_csv",
        "number": 0,
        "param_names": [
            "num_lines"
        ],
        "params": [
            [
                "10",
                "100",
                "10000",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "527d34c15d3f59499d23933839e9ed2774a7d72f5720f961041d449fec6e75b1",
        "warmup_time": -1
    },
    "bench_io.LoadtxtCSVDateTime.time_loadtxt_csv_datetime": {
        "code": "class LoadtxtCSVDateTime:\n    def time_loadtxt_csv_datetime(self, num_lines):\n        # rewind StringIO object -- the timing iterations\n        # are state-dependent\n        X = np.loadtxt(self.csv_data,\n                       delimiter=',',\n                       dtype=([('dates', 'M8[us]'),\n                               ('values', 'float64')]))\n        self.csv_data.seek(0)\n\n    def setup(self, num_lines):\n        # create the equivalent of a two-column CSV file\n        # with date strings in the first column and random\n        # floating point data in the second column\n        dates = np.arange('today', 20, dtype=np.datetime64)\n        np.random.seed(123)\n        values = np.random.rand(20)\n        date_line = ''\n    \n        for date, value in zip(dates, values):\n            date_line += (str(date) + ',' + str(value) + '\\n')\n    \n        # expand data to specified number of lines\n        data = date_line * (num_lines // 20)\n        self.csv_data = StringIO(data)",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtCSVDateTime.time_loadtxt_csv_datetime",
        "number": 0,
        "param_names": [
            "num_lines"
        ],
        "params": [
            [
                "20",
                "200",
                "2000",
                "20000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ca4b6d747d9d6734cbb7bad3d6636c23bc828717f5c3cdc9bbc4011e4b2beaa2",
        "warmup_time": -1
    },
    "bench_io.LoadtxtCSVSkipRows.time_skiprows_csv": {
        "code": "class LoadtxtCSVSkipRows:\n    def time_skiprows_csv(self, skiprows):\n        np.loadtxt(self.fname,\n                   delimiter=',',\n                   skiprows=skiprows)\n\n    def setup(self, skiprows):\n        np.random.seed(123)\n        test_array = np.random.rand(100000, 3)\n        self.fname = 'test_array.csv'\n        np.savetxt(fname=self.fname,\n                   X=test_array,\n                   delimiter=',')",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtCSVSkipRows.time_skiprows_csv",
        "number": 0,
        "param_names": [
            "skiprows"
        ],
        "params": [
            [
                "0",
                "500",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3e404fbe768ffacb38decdc20759baa4c49675a337db49def01ca2ad8ec05f2b",
        "warmup_time": -1
    },
    "bench_io.LoadtxtCSVStructured.time_loadtxt_csv_struct_dtype": {
        "code": "class LoadtxtCSVStructured:\n    def time_loadtxt_csv_struct_dtype(self):\n        # obligate rewind of StringIO object\n        # between iterations of a repeat:\n    \n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   dtype=[('category_1', 'S1'),\n                          ('category_2', 'i4'),\n                          ('category_3', 'f8'),\n                          ('category_4', 'S1'),\n                          ('category_5', 'f8')])\n        self.csv_data.seek(0)\n\n    def setup(self):\n        num_lines = 50000\n        data = [\"M, 21, 72, X, 155\"] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtCSVStructured.time_loadtxt_csv_struct_dtype",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d236c8076ec7d1306b444fd6bfc435c8a78186c0d9c05ac68b7de4d9a9c48c93",
        "warmup_time": -1
    },
    "bench_io.LoadtxtCSVdtypes.time_loadtxt_dtypes_csv": {
        "code": "class LoadtxtCSVdtypes:\n    def time_loadtxt_dtypes_csv(self, dtype, num_lines):\n        # benchmark loading arrays of various dtypes\n        # from csv files\n    \n        # state-dependent timing benchmark requires\n        # rewind of StringIO object\n    \n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   dtype=dtype)\n        self.csv_data.seek(0)\n\n    def setup(self, dtype, num_lines):\n        data = ['5, 7, 888'] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtCSVdtypes.time_loadtxt_dtypes_csv",
        "number": 0,
        "param_names": [
            "dtype",
            "num_lines"
        ],
        "params": [
            [
                "'float32'",
                "'float64'",
                "'int32'",
                "'int64'",
                "'complex128'",
                "'str'",
                "'object'"
            ],
            [
                "10",
                "100",
                "10000",
                "100000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3b026040fb38600a75f663e806cea93f834736591f99756972d616f4f1f4ddfc",
        "warmup_time": -1
    },
    "bench_io.LoadtxtReadUint64Integers.time_read_uint64": {
        "code": "class LoadtxtReadUint64Integers:\n    def time_read_uint64(self, size):\n        # mandatory rewind of StringIO object\n        # between iterations of a repeat:\n        np.loadtxt(self.data1)\n        self.data1.seek(0)\n\n    def setup(self, size):\n        arr = np.arange(size).astype('uint64') + 2**63\n        self.data1 = StringIO('\\n'.join(arr.astype(str).tolist()))\n        arr = arr.astype(object)\n        arr[500] = -1\n        self.data2 = StringIO('\\n'.join(arr.astype(str).tolist()))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtReadUint64Integers.time_read_uint64",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "550",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "adea3edd8d53ff3f6ba2a1d35bb9f07b8854d1559de84f52f770d3bce45acf19",
        "warmup_time": -1
    },
    "bench_io.LoadtxtReadUint64Integers.time_read_uint64_neg_values": {
        "code": "class LoadtxtReadUint64Integers:\n    def time_read_uint64_neg_values(self, size):\n        # mandatory rewind of StringIO object\n        # between iterations of a repeat:\n        np.loadtxt(self.data2)\n        self.data2.seek(0)\n\n    def setup(self, size):\n        arr = np.arange(size).astype('uint64') + 2**63\n        self.data1 = StringIO('\\n'.join(arr.astype(str).tolist()))\n        arr = arr.astype(object)\n        arr[500] = -1\n        self.data2 = StringIO('\\n'.join(arr.astype(str).tolist()))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtReadUint64Integers.time_read_uint64_neg_values",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "550",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6a9872bc06310337a9284c05f6fc4454314ea78241afefc341c4fc9f283814bf",
        "warmup_time": -1
    },
    "bench_io.LoadtxtUseColsCSV.time_loadtxt_usecols_csv": {
        "code": "class LoadtxtUseColsCSV:\n    def time_loadtxt_usecols_csv(self, usecols):\n        # must rewind StringIO because of state\n        # dependence of file reading\n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   usecols=usecols)\n        self.csv_data.seek(0)\n\n    def setup(self, usecols):\n        num_lines = 5000\n        data = ['0, 1, 2, 3, 4, 5, 6, 7, 8, 9'] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))",
        "min_run_count": 2,
        "name": "bench_io.LoadtxtUseColsCSV.time_loadtxt_usecols_csv",
        "number": 0,
        "param_names": [
            "usecols"
        ],
        "params": [
            [
                "2",
                "[1, 3]",
                "[1, 3, 5, 7]"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6767a50e078d8b82657e856649c176b41222e6097da66a4094631164a7579747",
        "warmup_time": -1
    },
    "bench_io.Savez.time_vb_savez_squares": {
        "code": "class Savez:\n    def time_vb_savez_squares(self):\n        np.savez('tmp.npz', **self.squares)\n\n    def setup(self):\n        self.squares = get_squares()",
        "min_run_count": 2,
        "name": "bench_io.Savez.time_vb_savez_squares",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1d68d79f6ca00119e591c2cf1dd228713f70a6478358c985911a0c76299407b1",
        "warmup_time": -1
    },
    "bench_itemselection.Put.time_ordered": {
        "code": "class Put:\n    def time_ordered(self, values_is_scalar, dtype):\n        np.put(self.arr, self.indx, self.vals)\n\n    def setup(self, values_is_scalar, dtype):\n        if values_is_scalar:\n            self.vals = np.array(1., dtype=dtype)\n        else:\n            self.vals = np.ones(1000, dtype=dtype)\n    \n        self.arr = np.ones(1000, dtype=dtype)\n        self.indx = np.arange(1000, dtype=np.intp)",
        "min_run_count": 2,
        "name": "bench_itemselection.Put.time_ordered",
        "number": 0,
        "param_names": [
            "values_is_scalar",
            "dtype"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "290dbfba0c69992df111df9225e77dde40981572f4efd897134734903c116f3d",
        "warmup_time": -1
    },
    "bench_itemselection.PutMask.time_dense": {
        "code": "class PutMask:\n    def time_dense(self, values_is_scalar, dtype):\n        np.putmask(self.arr, self.dense_mask, self.vals)\n\n    def setup(self, values_is_scalar, dtype):\n        if values_is_scalar:\n            self.vals = np.array(1., dtype=dtype)\n        else:\n            self.vals = np.ones(1000, dtype=dtype)\n    \n        self.arr = np.ones(1000, dtype=dtype)\n    \n        self.dense_mask = np.ones(1000, dtype=\"bool\")\n        self.sparse_mask = np.zeros(1000, dtype=\"bool\")",
        "min_run_count": 2,
        "name": "bench_itemselection.PutMask.time_dense",
        "number": 0,
        "param_names": [
            "values_is_scalar",
            "dtype"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "166dfab55086e824fc45c71ba79ed453e0de08edbd84c71a8b60468e93c27c89",
        "warmup_time": -1
    },
    "bench_itemselection.PutMask.time_sparse": {
        "code": "class PutMask:\n    def time_sparse(self, values_is_scalar, dtype):\n        np.putmask(self.arr, self.sparse_mask, self.vals)\n\n    def setup(self, values_is_scalar, dtype):\n        if values_is_scalar:\n            self.vals = np.array(1., dtype=dtype)\n        else:\n            self.vals = np.ones(1000, dtype=dtype)\n    \n        self.arr = np.ones(1000, dtype=dtype)\n    \n        self.dense_mask = np.ones(1000, dtype=\"bool\")\n        self.sparse_mask = np.zeros(1000, dtype=\"bool\")",
        "min_run_count": 2,
        "name": "bench_itemselection.PutMask.time_sparse",
        "number": 0,
        "param_names": [
            "values_is_scalar",
            "dtype"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dadc5e4b5b3dd8f832173b7b7e1f8efd82503d4238e6691b90e9969fd2828f9c",
        "warmup_time": -1
    },
    "bench_itemselection.Take.time_contiguous": {
        "code": "class Take:\n    def time_contiguous(self, shape, mode, dtype):\n        self.arr.take(self.indices, axis=-2, mode=mode)\n\n    def setup(self, shape, mode, dtype):\n        self.arr = np.ones(shape, dtype)\n        self.indices = np.arange(1000)",
        "min_run_count": 2,
        "name": "bench_itemselection.Take.time_contiguous",
        "number": 0,
        "param_names": [
            "shape",
            "mode",
            "dtype"
        ],
        "params": [
            [
                "(1000, 1)",
                "(2, 1000, 1)",
                "(1000, 3)"
            ],
            [
                "'raise'",
                "'wrap'",
                "'clip'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'O'",
                "'i,O'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "464749957650ef1727b83afc00207bcd11ac8a1d60cd0d9352c205b4cbab00d0",
        "warmup_time": -1
    },
    "bench_lib.Isin.time_isin": {
        "code": "class Isin:\n    def time_isin(self, size, highest_element):\n        np.isin(self.array, self.in_array)\n\n    def setup(self, size, highest_element):\n        self.array = np.random.randint(\n                low=0, high=highest_element, size=size)\n        self.in_array = np.random.randint(\n                low=0, high=highest_element, size=size)",
        "min_run_count": 2,
        "name": "bench_lib.Isin.time_isin",
        "number": 0,
        "param_names": [
            "size",
            "highest_element"
        ],
        "params": [
            [
                "10",
                "100000",
                "3000000"
            ],
            [
                "10",
                "10000",
                "100000000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "990e50d77ff5825f429cf0b636cbd867c11bde5228659384ea04bade0076637d",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanargmax": {
        "code": "class Nan:\n    def time_nanargmax(self, array_size, percent_nans):\n        np.nanargmax(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanargmax",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cc4c5b8336d11c7af3dd1d35631a960e3551f46b9da94882ef82a858ad5279e1",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanargmin": {
        "code": "class Nan:\n    def time_nanargmin(self, array_size, percent_nans):\n        np.nanargmin(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanargmin",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "771d88adce5f928927a93e6f10f59cdb324dadb6eec887261a5ef263acc16928",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nancumprod": {
        "code": "class Nan:\n    def time_nancumprod(self, array_size, percent_nans):\n        np.nancumprod(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nancumprod",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "209232670d5c269f5b281b3b887e9862e2c0dd8d3bb18517dab1bb9a003cb539",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nancumsum": {
        "code": "class Nan:\n    def time_nancumsum(self, array_size, percent_nans):\n        np.nancumsum(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nancumsum",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "69b1f017d6c0c968f13af8ea9b6e2eafb0f6188b6f90a53261f9b89b221232e4",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanmax": {
        "code": "class Nan:\n    def time_nanmax(self, array_size, percent_nans):\n        np.nanmax(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanmax",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "93719cff0b9e55a19da372c0c333672e929271fd52a4dff1103ac5fbd497538c",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanmean": {
        "code": "class Nan:\n    def time_nanmean(self, array_size, percent_nans):\n        np.nanmean(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanmean",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "65809488afe83af6981a63e65782e8512197015c84da355a5dbb56dbc0206db8",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanmedian": {
        "code": "class Nan:\n    def time_nanmedian(self, array_size, percent_nans):\n        np.nanmedian(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanmedian",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "111d3b5ad6800d19365f6f23f1199335271cf21d2ba6b4656ab5256b80cf917e",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanmin": {
        "code": "class Nan:\n    def time_nanmin(self, array_size, percent_nans):\n        np.nanmin(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanmin",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cdec9e6c834eaa875bba1d1ed86d60aaaeecf1845cf69e3b647230a75dc8f69a",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanpercentile": {
        "code": "class Nan:\n    def time_nanpercentile(self, array_size, percent_nans):\n        np.nanpercentile(self.arr, q=50)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanpercentile",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c2726cf2d8788d03b3c4a4ab46117d64a4dd2b73e731cfa565d289dfb6f1c29a",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanprod": {
        "code": "class Nan:\n    def time_nanprod(self, array_size, percent_nans):\n        np.nanprod(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanprod",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d8e5aeed89ade6e4f00cf4289f2f9348abea38ac449ee444528aea19599e1959",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanquantile": {
        "code": "class Nan:\n    def time_nanquantile(self, array_size, percent_nans):\n        np.nanquantile(self.arr, q=0.2)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanquantile",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6b5f9bccdb15f5b931f445ca5412eea3e98d070c0ce2e7ba1fa626557e2bad0c",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanstd": {
        "code": "class Nan:\n    def time_nanstd(self, array_size, percent_nans):\n        np.nanstd(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanstd",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8da49c0fb221872a7b86a831b2b9ed993e6ec81aa8d4edcb3819babe2e70f6f8",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nansum": {
        "code": "class Nan:\n    def time_nansum(self, array_size, percent_nans):\n        np.nansum(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nansum",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c879ca3b2e8e737fda3f4582d7b5ec8671442e8fc66e5a75cb8caa6e0ccfd6fd",
        "warmup_time": -1
    },
    "bench_lib.Nan.time_nanvar": {
        "code": "class Nan:\n    def time_nanvar(self, array_size, percent_nans):\n        np.nanvar(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        rnd = np.random.RandomState(1819780348)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = rnd.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Nan.time_nanvar",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "01de799a67021d6284b677da1c7306591498bb40783ff1212ba98bd34d7cf0b5",
        "warmup_time": -1
    },
    "bench_lib.Pad.time_pad": {
        "code": "class Pad:\n    def time_pad(self, shape, pad_width, mode):\n        np.pad(self.array, pad_width, mode)\n\n    def setup(self, shape, pad_width, mode):\n        # Make sure to fill the array to make the OS page fault\n        # in the setup phase and not the timed phase\n        self.array = np.full(shape, fill_value=1, dtype=np.float64)",
        "min_run_count": 2,
        "name": "bench_lib.Pad.time_pad",
        "number": 0,
        "param_names": [
            "shape",
            "pad_width",
            "mode"
        ],
        "params": [
            [
                "(4194304,)",
                "(1024, 1024)",
                "(256, 128, 1)",
                "(4, 4, 4, 4)",
                "(1, 1, 1, 1, 1)"
            ],
            [
                "1",
                "8",
                "(0, 32)"
            ],
            [
                "'constant'",
                "'edge'",
                "'linear_ramp'",
                "'mean'",
                "'reflect'",
                "'wrap'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b4277ec92e77c2bf4bb0b2a8e8dce9197194cef3f65e13f14bd7fb5b7e74a8ac",
        "warmup_time": -1
    },
    "bench_lib.Unique.time_unique_all": {
        "code": "class Unique:\n    def time_unique_all(self, array_size, percent_nans):\n        np.unique(self.arr, return_index=True,\n                  return_inverse=True, return_counts=True)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        n_nan = int(percent_nans * array_size)\n        nan_indices = np.random.choice(np.arange(array_size), size=n_nan)\n        base_array[nan_indices] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Unique.time_unique_all",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bca27b4d0b894fe95533d5465e403d70b2143746a1c058fefba1512317359548",
        "warmup_time": -1
    },
    "bench_lib.Unique.time_unique_counts": {
        "code": "class Unique:\n    def time_unique_counts(self, array_size, percent_nans):\n        np.unique(self.arr, return_index=False,\n                  return_inverse=False, return_counts=True)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        n_nan = int(percent_nans * array_size)\n        nan_indices = np.random.choice(np.arange(array_size), size=n_nan)\n        base_array[nan_indices] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Unique.time_unique_counts",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7889cc5f8eba4c867b710697e206395fc55f5cbd3b5bcdaa54ff5bee4a46f18c",
        "warmup_time": -1
    },
    "bench_lib.Unique.time_unique_inverse": {
        "code": "class Unique:\n    def time_unique_inverse(self, array_size, percent_nans):\n        np.unique(self.arr, return_index=False,\n                  return_inverse=True, return_counts=False)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        n_nan = int(percent_nans * array_size)\n        nan_indices = np.random.choice(np.arange(array_size), size=n_nan)\n        base_array[nan_indices] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Unique.time_unique_inverse",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "39d5e3acff48cdc1287910e1117dd56053dda3c03f296c3a5ed8e7605f2bf152",
        "warmup_time": -1
    },
    "bench_lib.Unique.time_unique_values": {
        "code": "class Unique:\n    def time_unique_values(self, array_size, percent_nans):\n        np.unique(self.arr, return_index=False,\n                  return_inverse=False, return_counts=False)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        n_nan = int(percent_nans * array_size)\n        nan_indices = np.random.choice(np.arange(array_size), size=n_nan)\n        base_array[nan_indices] = np.nan\n        self.arr = base_array",
        "min_run_count": 2,
        "name": "bench_lib.Unique.time_unique_values",
        "number": 0,
        "param_names": [
            "array_size",
            "percent_nans"
        ],
        "params": [
            [
                "200",
                "200000"
            ],
            [
                "0",
                "0.1",
                "2.0",
                "50.0",
                "90.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0bf1bf1edf31db70719c1c8ec046ef504fe44d2324527ad63660c2aa8c54919d",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_a_b": {
        "code": "class Eindot:\n    def time_dot_a_b(self):\n        np.dot(self.a, self.b)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_a_b",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fc7b64772587d2fcfc57cc1c42a1211120555f4dfa85ea9cc0fd661bc0e8944b",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_d_dot_b_c": {
        "code": "class Eindot:\n    def time_dot_d_dot_b_c(self):\n        np.dot(self.d, np.dot(self.b, self.c))\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_d_dot_b_c",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cd8b7a425ea8afbc15713a9d4354e26b384bcd0b53535bd5cf9764b3711ff99d",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_trans_a_at": {
        "code": "class Eindot:\n    def time_dot_trans_a_at(self):\n        np.dot(self.a, self.at)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_trans_a_at",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cadaafc481fc33417b7e57f3fb687c73667e162f7d30ffde1fc6b90382f416e7",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_trans_a_atc": {
        "code": "class Eindot:\n    def time_dot_trans_a_atc(self):\n        np.dot(self.a, self.atc)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_trans_a_atc",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bb31adfaad837be36114234fece805792edb953bef687d8aa3edcfd923d56cb8",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_trans_at_a": {
        "code": "class Eindot:\n    def time_dot_trans_at_a(self):\n        np.dot(self.at, self.a)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_trans_at_a",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "756a34ed12e961c9b60d631ef7a05a483b313e12f2ef40d6155e577c3ee0679a",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_dot_trans_atc_a": {
        "code": "class Eindot:\n    def time_dot_trans_atc_a(self):\n        np.dot(self.atc, self.a)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_dot_trans_atc_a",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8f1f7de4d0eff8642c3b0e2a2c8daabb604e81f43c54cdb1693e67cce44caa61",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_einsum_i_ij_j": {
        "code": "class Eindot:\n    def time_einsum_i_ij_j(self):\n        np.einsum('i,ij,j', self.d, self.b, self.c)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_einsum_i_ij_j",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "288e8e612c86a681276c2aa248de6c8825c1c48296030d37a7a3753e6fd3a2b3",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_einsum_ij_jk_a_b": {
        "code": "class Eindot:\n    def time_einsum_ij_jk_a_b(self):\n        np.einsum('ij,jk', self.a, self.b)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_einsum_ij_jk_a_b",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6916501c528042009c5a86fb627051d470c97b333ba309fa80ca41e140970e60",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_einsum_ijk_jil_kl": {
        "code": "class Eindot:\n    def time_einsum_ijk_jil_kl(self):\n        np.einsum('ijk,jil->kl', self.a3, self.b3)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_einsum_ijk_jil_kl",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "efedb22caaf14c5ca95cb5f62625f79f5ac7dfd21366ba40625f90517e8d62ce",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_inner_trans_a_a": {
        "code": "class Eindot:\n    def time_inner_trans_a_a(self):\n        np.inner(self.a, self.a)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_inner_trans_a_a",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b94c9b6f108b19f0c93fc17841c851ff7fe3328e1dd5f00ff1f07e342df22d15",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_inner_trans_a_ac": {
        "code": "class Eindot:\n    def time_inner_trans_a_ac(self):\n        np.inner(self.a, self.ac)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_inner_trans_a_ac",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "130a320c033a16f6debf7a10e50034f1111eb832648bcb1542f3f33f785e9224",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_a_b": {
        "code": "class Eindot:\n    def time_matmul_a_b(self):\n        np.matmul(self.a, self.b)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_a_b",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d90655a686a3163a5da0faefa694a75b002ae3b92e658e857d936005509a4fb5",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_d_matmul_b_c": {
        "code": "class Eindot:\n    def time_matmul_d_matmul_b_c(self):\n        np.matmul(self.d, np.matmul(self.b, self.c))\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_d_matmul_b_c",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "41de192e4eb84d32be37c56d9d531411d2a76d7b39e14721609a4cb7a3877564",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_trans_a_at": {
        "code": "class Eindot:\n    def time_matmul_trans_a_at(self):\n        np.matmul(self.a, self.at)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_trans_a_at",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7184f1bcfd1b4ffbf68190792040b8fa7f198d7fc0aa431425588e77da889fe6",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_trans_a_atc": {
        "code": "class Eindot:\n    def time_matmul_trans_a_atc(self):\n        np.matmul(self.a, self.atc)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_trans_a_atc",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5781cb7e053bd2ec71d05c0394748b1c89e0d87aaf0566d5dc47eeb5c3b8121d",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_trans_at_a": {
        "code": "class Eindot:\n    def time_matmul_trans_at_a(self):\n        np.matmul(self.at, self.a)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_trans_at_a",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dc58070e9389181053802704c01bb4589b3bcba34185ad3df45e7b2d6a7c3652",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_matmul_trans_atc_a": {
        "code": "class Eindot:\n    def time_matmul_trans_atc_a(self):\n        np.matmul(self.atc, self.a)\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_matmul_trans_atc_a",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "caeac19741b9ca68a63e8c7d46e2c9458a732dd3a86c45b04b4e227dd1abf5db",
        "warmup_time": -1
    },
    "bench_linalg.Eindot.time_tensordot_a_b_axes_1_0_0_1": {
        "code": "class Eindot:\n    def time_tensordot_a_b_axes_1_0_0_1(self):\n        np.tensordot(self.a3, self.b3, axes=([1, 0], [0, 1]))\n\n    def setup(self):\n        eindot_sizes = bench_sizes['bench_linalg.Eindot']\n        a_dims = make_tuple(eindot_sizes[\"a\"])\n        b_dims = make_tuple(eindot_sizes[\"b\"])\n        self.a = np.arange(a_dims[0] * a_dims[1] * 1.0).reshape(a_dims[0], a_dims[1])\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(b_dims[0] * b_dims[1] * 1.0).reshape(b_dims[0], b_dims[1])\n        self.c = np.arange(int(eindot_sizes[\"c\"]))\n        self.d = np.arange(int(eindot_sizes[\"d\"]))\n    \n        a3_dims = make_tuple(eindot_sizes[\"a3\"])\n        b3_dims = make_tuple(eindot_sizes[\"b3\"])\n        self.a3 = np.arange(a3_dims[0] * a3_dims[1] * a3_dims[2] * 1.0).reshape(\n            a3_dims[0], a3_dims[1], a3_dims[2])\n        self.b3 = np.arange(b3_dims[0] * b3_dims[1] * b3_dims[2] * 1.0).reshape(\n            b3_dims[0], b3_dims[1], b3_dims[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Eindot.time_tensordot_a_b_axes_1_0_0_1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "367ae171f0947c61212dd8dfc5f027726631e61c602e1c8c8f3185df8ab999d8",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_contig_contig": {
        "code": "class Einsum:\n    def time_einsum_contig_contig(self, dtype):\n        np.einsum(\"ji,i->\", self.two_dim, self.one_dim_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_contig_contig",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8f163625b46ae2f87152b6930f7b17a443dd0a31aef1b9ee0b3141ef6ec56ee7",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_contig_outstride0": {
        "code": "class Einsum:\n    def time_einsum_contig_outstride0(self, dtype):\n        np.einsum(\"i->\", self.one_dim_big, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_contig_outstride0",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3496a4a3843e9099795074d4a4f0db7f3fa9d15138adaea4176a362d081e3dfc",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_mul": {
        "code": "class Einsum:\n    def time_einsum_mul(self, dtype):\n        np.einsum(\"i,->i\", self.one_dim_big, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_mul",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0791751c6a0833c22ef1758a5524770e597205dfd3cbe108b8a59c686a6aa5df",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_multiply": {
        "code": "class Einsum:\n    def time_einsum_multiply(self, dtype):\n        np.einsum(\"..., ...\", self.two_dim_small, self.three_dim , optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_multiply",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f99bee7e1eff13357aca208894c1a257b7f524354b64ef8f381563fbbace488e",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_contig_contig": {
        "code": "class Einsum:\n    def time_einsum_noncon_contig_contig(self, dtype):\n        np.einsum(\"ji,i->\", self.non_contiguous_dim2, self.non_contiguous_dim1_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_contig_contig",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "420645372b1af897545830f4a0027ea1ab81b38ad24aafb62f3702ff7c7907cb",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_contig_outstride0": {
        "code": "class Einsum:\n    def time_einsum_noncon_contig_outstride0(self, dtype):\n        np.einsum(\"i->\", self.non_contiguous_dim1, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_contig_outstride0",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3e48f8ea00eb4622bcc12db62c7c85572c72c226b6b0413e1439c3a8c30f92d6",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_mul": {
        "code": "class Einsum:\n    def time_einsum_noncon_mul(self, dtype):\n        np.einsum(\"i,->i\", self.non_contiguous_dim1, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_mul",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bf7c10b140996f6f26ba402877241c912a3719242eaf7f79813dd6871778570f",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_multiply": {
        "code": "class Einsum:\n    def time_einsum_noncon_multiply(self, dtype):\n        np.einsum(\"..., ...\", self.non_contiguous_dim2, self.non_contiguous_dim3, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_multiply",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8f16daa90b3bda4bd31563e2a96cc1f8e416a1714a13c3f0642d29d05ce233fe",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_outer": {
        "code": "class Einsum:\n    def time_einsum_noncon_outer(self, dtype):\n        np.einsum(\"i,j\", self.non_contiguous_dim1, self.non_contiguous_dim1, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_outer",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2c573a6db2dfc117b04e34c408a29904fef5ed5e61617c46dff968bfdf78ff78",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_sum_mul": {
        "code": "class Einsum:\n    def time_einsum_noncon_sum_mul(self, dtype):\n        np.einsum(\",i...->\", 300, self.non_contiguous_dim3, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_sum_mul",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a7626e1b502b938e58133d969ef79b86e51568fe0e5e21b7ccf3cf0bae410600",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_noncon_sum_mul2": {
        "code": "class Einsum:\n    def time_einsum_noncon_sum_mul2(self, dtype):\n        np.einsum(\"i...,->\", self.non_contiguous_dim3, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_noncon_sum_mul2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3fe9b2f02cf9d9c819ba33e047725bd0c0495ae38d257615e9fbbce820bdde50",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_outer": {
        "code": "class Einsum:\n    def time_einsum_outer(self, dtype):\n        np.einsum(\"i,j\", self.one_dim, self.one_dim, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_outer",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9f6490beb2e352e4185d6ba5f0f2d6df98ba980b5d2b0c34967b6f8cdf1811f7",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_sum_mul": {
        "code": "class Einsum:\n    def time_einsum_sum_mul(self, dtype):\n        np.einsum(\",i...->\", 300, self.three_dim_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_sum_mul",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9a8e67d9954451e5b42326fe52cfc839634db004be03febdd396a44d0666e310",
        "warmup_time": -1
    },
    "bench_linalg.Einsum.time_einsum_sum_mul2": {
        "code": "class Einsum:\n    def time_einsum_sum_mul2(self, dtype):\n        np.einsum(\"i...,->\", self.three_dim_small, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_small\"]), dtype=dtype)\n        self.one_dim = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim\"]), dtype=dtype)\n        self.one_dim_big = np.arange(int(bench_sizes[\"bench_linalg.Einsum\"][\"one_dim_big\"]), dtype=dtype)\n    \n        dim2s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim_small\"])\n        dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"two_dim\"])\n        self.two_dim_small = np.arange(dim2s[0] * dim2s[1], dtype=dtype).reshape(dim2s[0], dim2s[1])\n        self.two_dim = np.arange(dim2[0] * dim2[1], dtype=dtype).reshape(dim2[0], dim2[1])\n        dim3s = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim_small\"])\n        dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"three_dim\"])\n        self.three_dim_small = np.arange(dim3s[0] * dim3s[1] * dim3s[2], dtype=dtype).reshape(\n            dim3s[0], dim3s[1], dim3s[2])\n        self.three_dim = np.arange(dim3[0] * dim3[1] * dim3[2], dtype=dtype).reshape(\n            dim3[0], dim3[1], dim3[2])\n        # non_contiguous arrays\n        nc_dim1s = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1_small\"])\n        nc_dim1 = int(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim1\"])\n        nc_dim2 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim2\"])\n        nc_dim3 = make_tuple(bench_sizes[\"bench_linalg.Einsum\"][\"non_contiguous_dim3\"])\n        self.non_contiguous_dim1_small = np.arange(1, nc_dim1s, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, nc_dim1, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, nc_dim2[0] * nc_dim2[1] * 2, 2, dtype=dtype).reshape(\n            nc_dim2[0], nc_dim2[1])\n        self.non_contiguous_dim3 = np.arange(1, nc_dim3[0] * nc_dim3[1] * nc_dim3[2] * 2, 2, dtype=dtype).reshape(\n            nc_dim3[0], nc_dim3[1], nc_dim3[2])",
        "min_run_count": 2,
        "name": "bench_linalg.Einsum.time_einsum_sum_mul2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ab996a180f931b1a2fed2649efd9c1e87ea57a45c4b1d2dfc570e76a5c188960",
        "warmup_time": -1
    },
    "bench_linalg.LinAlgTransposeVdot.time_transpose": {
        "code": "class LinAlgTransposeVdot:\n    def time_transpose(self, shape, npdtypes):\n        np.transpose(self.xarg)\n\n    def setup(self, shape, npdtypes):\n        self.xarg = np.random.uniform(-1, 1, np.dot(*shape)).reshape(shape)\n        self.xarg = self.xarg.astype(npdtypes)\n        self.x2arg = np.random.uniform(-1, 1, np.dot(*shape)).reshape(shape)\n        self.x2arg = self.x2arg.astype(npdtypes)\n        if npdtypes.startswith('complex'):\n            self.xarg += self.xarg.T*1j\n            self.x2arg += self.x2arg.T*1j",
        "min_run_count": 2,
        "name": "bench_linalg.LinAlgTransposeVdot.time_transpose",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "(32, 32)",
                "(64, 64)",
                "(128, 128)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b94d7c27b09f00b14b24c62ff2316066808cf1d60c728beed1337f763ed07e96",
        "warmup_time": -1
    },
    "bench_linalg.LinAlgTransposeVdot.time_vdot": {
        "code": "class LinAlgTransposeVdot:\n    def time_vdot(self, shape, npdtypes):\n        np.vdot(self.xarg, self.x2arg)\n\n    def setup(self, shape, npdtypes):\n        self.xarg = np.random.uniform(-1, 1, np.dot(*shape)).reshape(shape)\n        self.xarg = self.xarg.astype(npdtypes)\n        self.x2arg = np.random.uniform(-1, 1, np.dot(*shape)).reshape(shape)\n        self.x2arg = self.x2arg.astype(npdtypes)\n        if npdtypes.startswith('complex'):\n            self.xarg += self.xarg.T*1j\n            self.x2arg += self.x2arg.T*1j",
        "min_run_count": 2,
        "name": "bench_linalg.LinAlgTransposeVdot.time_vdot",
        "number": 0,
        "param_names": [
            "shape",
            "npdtypes"
        ],
        "params": [
            [
                "(32, 32)",
                "(64, 64)",
                "(128, 128)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "44e9248c17dcaff5d6efb659faffd5ca2cb32c48ce3c5acf9d2df04a0d0eba8a",
        "warmup_time": -1
    },
    "bench_linalg.Linalg.time_det": {
        "code": "class Linalg:\n    def time_det(self, typename):\n        np.linalg.det(self.a)\n\n    def setup(self, typename):\n        np.seterr(all='ignore')\n        self.a = get_squares_()[typename]",
        "min_run_count": 2,
        "name": "bench_linalg.Linalg.time_det",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'complex128'",
                "'complex64'",
                "'float32'",
                "'float64'",
                "'int16'",
                "'int32'",
                "'int64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c861050c46d3def9d98b967dee191f6f83c05176867fbfabbebaca1fa8578267",
        "warmup_time": -1
    },
    "bench_linalg.Linalg.time_pinv": {
        "code": "class Linalg:\n    def time_pinv(self, typename):\n        np.linalg.pinv(self.a)\n\n    def setup(self, typename):\n        np.seterr(all='ignore')\n        self.a = get_squares_()[typename]",
        "min_run_count": 2,
        "name": "bench_linalg.Linalg.time_pinv",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'complex128'",
                "'complex64'",
                "'float32'",
                "'float64'",
                "'int16'",
                "'int32'",
                "'int64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c3eff507fc03b7e279b9edba6cb05898586bb7152ccd68aacf01032dc6643615",
        "warmup_time": -1
    },
    "bench_linalg.Linalg.time_svd": {
        "code": "class Linalg:\n    def time_svd(self, typename):\n        np.linalg.svd(self.a)\n\n    def setup(self, typename):\n        np.seterr(all='ignore')\n        self.a = get_squares_()[typename]",
        "min_run_count": 2,
        "name": "bench_linalg.Linalg.time_svd",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'complex128'",
                "'complex64'",
                "'float32'",
                "'float64'",
                "'int16'",
                "'int32'",
                "'int64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dcb4ba838b3e9d74683e1e7e1afd77b863b5e44fc0dbe83bcade1c74d21d40db",
        "warmup_time": -1
    },
    "bench_linalg.LinalgNorm.time_norm": {
        "code": "class LinalgNorm:\n    def time_norm(self, typename):\n        np.linalg.norm(self.a)\n\n    def setup(self, typename):\n        self.a = get_squares_()[typename]",
        "min_run_count": 2,
        "name": "bench_linalg.LinalgNorm.time_norm",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d8544d6d6751e8816e186c5b921f3649de5553f4a7fd3db849f3b7586967c46f",
        "warmup_time": -1
    },
    "bench_linalg.LinalgSmallArrays.time_det_small_array": {
        "code": "class LinalgSmallArrays:\n    def time_det_small_array(self):\n        np.linalg.det(self.array_5_5)\n\n    def setup(self):\n        self.array_5 = np.arange(5.)\n        self.array_5_5 = np.reshape(np.arange(25.), (5, 5))",
        "min_run_count": 2,
        "name": "bench_linalg.LinalgSmallArrays.time_det_small_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a9061e2298a949c5af224b9743b97e7636c1bc2362fdd6867508c9a448001a3f",
        "warmup_time": -1
    },
    "bench_linalg.LinalgSmallArrays.time_norm_small_array": {
        "code": "class LinalgSmallArrays:\n    def time_norm_small_array(self):\n        np.linalg.norm(self.array_5)\n\n    def setup(self):\n        self.array_5 = np.arange(5.)\n        self.array_5_5 = np.reshape(np.arange(25.), (5, 5))",
        "min_run_count": 2,
        "name": "bench_linalg.LinalgSmallArrays.time_norm_small_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7cec70c2d05f3741e47cff7c6a472ee36923758fc8ee8b82ca4b1050604727ea",
        "warmup_time": -1
    },
    "bench_linalg.Lstsq.time_numpy_linalg_lstsq_a__b_float64": {
        "code": "class Lstsq:\n    def time_numpy_linalg_lstsq_a__b_float64(self):\n        np.linalg.lstsq(self.a, self.b, rcond=-1)\n\n    def setup(self):\n        self.a = get_squares_()['float64']\n        self.b = get_indexes_rand()[:100].astype(np.float64)",
        "min_run_count": 2,
        "name": "bench_linalg.Lstsq.time_numpy_linalg_lstsq_a__b_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8986b54baed47d44faf78455a011ab17ccdfb51cc62cf0e48087f054a52c29e6",
        "warmup_time": -1
    },
    "bench_ma.Concatenate.time_it": {
        "code": "class Concatenate:\n    def time_it(self, mode, n):\n        np.ma.concatenate(self.args)\n\n    def setup(self, mode, n):\n        # avoid np.zeros's lazy allocation that cause page faults during benchmark.\n        # np.fill will cause pagefaults to happen during setup.\n        normal = np.full((n, n), 0, int)\n        unmasked = np.ma.zeros((n, n), int)\n        masked = np.ma.array(normal, mask=True)\n    \n        mode_parts = mode.split('+')\n        base = mode_parts[0]\n        promote = 'masked' in mode_parts[1:]\n    \n        if base == 'ndarray':\n            args = 10 * (normal,)\n        elif base == 'unmasked':\n            args = 10 * (unmasked,)\n        else:\n            args = 10 * (masked,)\n    \n        if promote:\n            args = args[:-1] + (masked,)\n    \n        self.args = args",
        "min_run_count": 2,
        "name": "bench_ma.Concatenate.time_it",
        "number": 0,
        "param_names": [
            "mode",
            "n"
        ],
        "params": [
            [
                "'ndarray'",
                "'unmasked'",
                "'ndarray+masked'",
                "'unmasked+masked'",
                "'masked'"
            ],
            [
                "2",
                "100",
                "2000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c5266b41dad24011ae7e64de9ff53d788ddeb5d55cbb4cff451dc49af0c70298",
        "warmup_time": -1
    },
    "bench_ma.Corrcoef.time_corrcoef": {
        "code": "class Corrcoef:\n    def time_corrcoef(self, size):\n        if size == \"small\":\n            np.ma.corrcoef(self.small)\n        if size == \"large\":\n            np.ma.corrcoef(self.large)\n\n    def setup(self, size):\n        # Set the proportion of masked values.\n        prop_mask = 0.2\n        # Set up a \"small\" array with 10 vars and 10 obs.\n        rng = np.random.default_rng()\n        data = rng.random((10, 10), dtype=np.float32)\n        self.small = np.ma.array(data, mask=(data <= prop_mask))\n        # Set up a \"large\" array with 100 vars and 100 obs.\n        data = rng.random((100, 100), dtype=np.float32)\n        self.large = np.ma.array(data, mask=(data <= prop_mask))",
        "min_run_count": 2,
        "name": "bench_ma.Corrcoef.time_corrcoef",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'small'",
                "'large'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "57632d38eb777999c58176ddfd3a1e7f3f9f8f26ac602b2a3732765d4b4ae865",
        "warmup_time": -1
    },
    "bench_ma.Cov.time_cov": {
        "code": "class Cov:\n    def time_cov(self, size):\n        if size == \"small\":\n            np.ma.cov(self.small)\n        if size == \"large\":\n            np.ma.cov(self.large)\n\n    def setup(self, size):\n        # Set the proportion of masked values.\n        prop_mask = 0.2\n        # Set up a \"small\" array with 10 vars and 10 obs.\n        rng = np.random.default_rng()\n        data = rng.random((10, 10), dtype=np.float32)\n        self.small = np.ma.array(data, mask=(data <= prop_mask))\n        # Set up a \"large\" array with 100 vars and 100 obs.\n        data = rng.random((100, 100), dtype=np.float32)\n        self.large = np.ma.array(data, mask=(data <= prop_mask))",
        "min_run_count": 2,
        "name": "bench_ma.Cov.time_cov",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "'small'",
                "'large'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9cf7c842a6a922e5f4b730d496fceabc6a0c36209fe3dd81daa267a15ecc0aab",
        "warmup_time": -1
    },
    "bench_ma.Indexing.time_0d": {
        "code": "class Indexing:\n    def time_0d(self, masked, ndim, size):\n        self.m[self.idx_0d]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)",
        "min_run_count": 2,
        "name": "bench_ma.Indexing.time_0d",
        "number": 0,
        "param_names": [
            "masked",
            "ndim",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "1",
                "2"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3af17398e826ce96894f8d9e3df13390b6057d8ab4646cccf3dafe3a6b530dea",
        "warmup_time": -1
    },
    "bench_ma.Indexing.time_1d": {
        "code": "class Indexing:\n    def time_1d(self, masked, ndim, size):\n        self.m[self.idx_1d]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)",
        "min_run_count": 2,
        "name": "bench_ma.Indexing.time_1d",
        "number": 0,
        "param_names": [
            "masked",
            "ndim",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "1",
                "2"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2dc73766d9324469077751387174000e90cd198310ae5d0b5bbfbe2b3a0b1d55",
        "warmup_time": -1
    },
    "bench_ma.Indexing.time_scalar": {
        "code": "class Indexing:\n    def time_scalar(self, masked, ndim, size):\n        self.m[self.idx_scalar]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)",
        "min_run_count": 2,
        "name": "bench_ma.Indexing.time_scalar",
        "number": 0,
        "param_names": [
            "masked",
            "ndim",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "1",
                "2"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "20842912a6d684f5d66c15e2ef6fc5994066b617ff4c673efb382b98bd70c190",
        "warmup_time": -1
    },
    "bench_ma.MA.time_masked_array": {
        "code": "class MA:\n    def time_masked_array(self):\n        np.ma.masked_array()\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)",
        "min_run_count": 2,
        "name": "bench_ma.MA.time_masked_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "569cb888c6b874c3b64957cab882b3e04f2d830d4581ce6aed29c758d2c32fa2",
        "warmup_time": -1
    },
    "bench_ma.MA.time_masked_array_l100": {
        "code": "class MA:\n    def time_masked_array_l100(self):\n        np.ma.masked_array(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)",
        "min_run_count": 2,
        "name": "bench_ma.MA.time_masked_array_l100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1bd9f2518b045c4e7f662bb4528b56e49605d20fd412c8657d0ef38741838eb5",
        "warmup_time": -1
    },
    "bench_ma.MA.time_masked_array_l100_t100": {
        "code": "class MA:\n    def time_masked_array_l100_t100(self):\n        np.ma.masked_array(self.l100, self.t100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)",
        "min_run_count": 2,
        "name": "bench_ma.MA.time_masked_array_l100_t100",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5756fb2ab73509c5b839cd02f3317b36da59fd9b3eee66bad94c4cde42a86bb9",
        "warmup_time": -1
    },
    "bench_ma.MACreation.time_ma_creations": {
        "code": "class MACreation:\n    def time_ma_creations(self, data, mask):\n        np.ma.array(data=np.zeros(int(data)), mask=mask)",
        "min_run_count": 2,
        "name": "bench_ma.MACreation.time_ma_creations",
        "number": 0,
        "param_names": [
            "data",
            "mask"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "True",
                "False",
                "None"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f966133729a78c368cf8654583f0f34111133f917bacae4bdce48de99b241b0b",
        "warmup_time": -1
    },
    "bench_ma.MAFunctions1v.time_functions_1v": {
        "code": "class MAFunctions1v:\n    def time_functions_1v(self, mtype, func, msize):\n        # fun = {'np.ma.sin': np.ma.sin, 'np.sin': np.sin}[func]\n        fun = eval(f\"{mtype}.{func}\")\n        if msize == 'small':\n            fun(self.nmxs)\n        elif msize == 'big':\n            fun(self.nmxl)\n\n    def setup(self, mtype, func, msize):\n        xs = 2.0 + np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = 2.0 + np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 2.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)",
        "min_run_count": 2,
        "name": "bench_ma.MAFunctions1v.time_functions_1v",
        "number": 0,
        "param_names": [
            "mtype",
            "func",
            "msize"
        ],
        "params": [
            [
                "'np'",
                "'np.ma'"
            ],
            [
                "'sin'",
                "'log'",
                "'sqrt'"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "82fa5b8a8a1d68802c704e268dbf117dd6d0031ca0f15d64c7e99343bba42e84",
        "warmup_time": -1
    },
    "bench_ma.MAFunctions2v.time_functions_2v": {
        "code": "class MAFunctions2v:\n    def time_functions_2v(self, mtype, func, msize):\n        fun = eval(f\"{mtype}.{func}\")\n        if msize == 'small':\n            fun(self.nmxs, self.nmys)\n        elif msize == 'big':\n            fun(self.nmxl, self.nmyl)\n\n    def setup(self, mtype, func, msize):\n        # Small arrays\n        xs = 2.0 + np.random.uniform(-1, 1, 6).reshape(2, 3)\n        ys = 2.0 + np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        m2 = [[True, False, True], [False, False, True]]\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmys = np.ma.array(ys, mask=m2)\n        # Big arrays\n        xl = 2.0 + np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        yl = 2.0 + np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 2.8\n        masky = yl < 1.8\n        self.nmxl = np.ma.array(xl, mask=maskx)\n        self.nmyl = np.ma.array(yl, mask=masky)",
        "min_run_count": 2,
        "name": "bench_ma.MAFunctions2v.time_functions_2v",
        "number": 0,
        "param_names": [
            "mtype",
            "func",
            "msize"
        ],
        "params": [
            [
                "'np'",
                "'np.ma'"
            ],
            [
                "'multiply'",
                "'divide'",
                "'power'"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "397ef80233831bb1601790b6f63a917f8f98b063a1566e84099871d477d5ac2d",
        "warmup_time": -1
    },
    "bench_ma.MAMethod0v.time_methods_0v": {
        "code": "class MAMethod0v:\n    def time_methods_0v(self, method, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, method)()\n\n    def setup(self, method, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)",
        "min_run_count": 2,
        "name": "bench_ma.MAMethod0v.time_methods_0v",
        "number": 0,
        "param_names": [
            "method",
            "msize"
        ],
        "params": [
            [
                "'ravel'",
                "'transpose'",
                "'compressed'",
                "'conjugate'"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ee2083ba8d5890db5c0b2f1e8169febf905441c816951937af4d13363d278c00",
        "warmup_time": -1
    },
    "bench_ma.MAMethodGetItem.time_methods_getitem": {
        "code": "class MAMethodGetItem:\n    def time_methods_getitem(self, margs, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, '__getitem__')(margs)\n\n    def setup(self, margs, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)",
        "min_run_count": 2,
        "name": "bench_ma.MAMethodGetItem.time_methods_getitem",
        "number": 0,
        "param_names": [
            "margs",
            "msize"
        ],
        "params": [
            [
                "0",
                "(0, 0)",
                "[0, -1]"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6ed77716301f0f917a324f47f7c2d269e01eda132efeefe8c801e599e67dc49d",
        "warmup_time": -1
    },
    "bench_ma.MAMethodSetItem.time_methods_setitem": {
        "code": "class MAMethodSetItem:\n    def time_methods_setitem(self, margs, mset, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, '__setitem__')(margs, mset)\n\n    def setup(self, margs, mset, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)",
        "min_run_count": 2,
        "name": "bench_ma.MAMethodSetItem.time_methods_setitem",
        "number": 0,
        "param_names": [
            "margs",
            "mset",
            "msize"
        ],
        "params": [
            [
                "0",
                "(0, 0)",
                "(-1, 0)"
            ],
            [
                "17",
                "masked"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8d4eb0f47f769df3bd5946b902a31618b0b55c5ccf615af52c895911e6eca776",
        "warmup_time": -1
    },
    "bench_ma.UFunc.time_1d": {
        "code": "class UFunc:\n    def time_1d(self, a_masked, b_masked, size):\n        np.ma.add(self.a_1d, self.b_1d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)",
        "min_run_count": 2,
        "name": "bench_ma.UFunc.time_1d",
        "number": 0,
        "param_names": [
            "a_masked",
            "b_masked",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3367abb12ea2e83d13287419c09a5fcfdec21cb8b976041105622e5f2455219a",
        "warmup_time": -1
    },
    "bench_ma.UFunc.time_2d": {
        "code": "class UFunc:\n    def time_2d(self, a_masked, b_masked, size):\n        # broadcasting happens this time\n        np.ma.add(self.a_2d, self.b_2d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)",
        "min_run_count": 2,
        "name": "bench_ma.UFunc.time_2d",
        "number": 0,
        "param_names": [
            "a_masked",
            "b_masked",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2f6eefd233384bed94c580db5fcefc09e11a86f0008ccf16cbf1dff95b0b9c23",
        "warmup_time": -1
    },
    "bench_ma.UFunc.time_scalar": {
        "code": "class UFunc:\n    def time_scalar(self, a_masked, b_masked, size):\n        np.ma.add(self.a_scalar, self.b_scalar)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)",
        "min_run_count": 2,
        "name": "bench_ma.UFunc.time_scalar",
        "number": 0,
        "param_names": [
            "a_masked",
            "b_masked",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4496f86f82cad9053c558f7f3b1f7a8ad9ccd4d18b3a7d5dd2e0dd1192c8e4d9",
        "warmup_time": -1
    },
    "bench_ma.UFunc.time_scalar_1d": {
        "code": "class UFunc:\n    def time_scalar_1d(self, a_masked, b_masked, size):\n        np.ma.add(self.a_scalar, self.b_1d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)",
        "min_run_count": 2,
        "name": "bench_ma.UFunc.time_scalar_1d",
        "number": 0,
        "param_names": [
            "a_masked",
            "b_masked",
            "size"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "98dfb3a1d0e42b2006cb34ac1dde59953825c9fbf5f1d3685a4ca3127525adc6",
        "warmup_time": -1
    },
    "bench_ma.Where.time_where": {
        "code": "class Where:\n    def time_where(self, mtype, msize):\n        fun = eval(f\"{mtype}.where\")\n        if msize == 'small':\n            fun(self.nmxs > 2, self.nmxs, self.nmys)\n        elif msize == 'big':\n            fun(self.nmxl > 2, self.nmxl, self.nmyl)\n\n    def setup(self, mtype, msize):\n        # Small arrays\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        ys = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        m2 = [[True, False, True], [False, False, True]]\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmys = np.ma.array(ys, mask=m2)\n        # Big arrays\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        yl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        masky = yl < -0.8\n        self.nmxl = np.ma.array(xl, mask=maskx)\n        self.nmyl = np.ma.array(yl, mask=masky)",
        "min_run_count": 2,
        "name": "bench_ma.Where.time_where",
        "number": 0,
        "param_names": [
            "mtype",
            "msize"
        ],
        "params": [
            [
                "'np'",
                "'np.ma'"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5b7b290076b801337934489edd30be7c1d0437b0db2586612d854e73e08ce173",
        "warmup_time": -1
    },
    "bench_manipulate.BroadcastArrays.time_broadcast_arrays": {
        "code": "class BroadcastArrays:\n    def time_broadcast_arrays(self, shape, ndtype):\n        np.broadcast_arrays(self.xarg, np.ones(1))\n\n    def setup(self, shape, ndtype):\n        self.xarg = np.random.ranf(shape[0]*shape[1]).reshape(shape)\n        self.xarg = self.xarg.astype(ndtype)\n        if ndtype.startswith('complex'):\n            self.xarg += np.random.ranf(1)*1j",
        "min_run_count": 2,
        "name": "bench_manipulate.BroadcastArrays.time_broadcast_arrays",
        "number": 0,
        "param_names": [
            "shape",
            "ndtype"
        ],
        "params": [
            [
                "(16, 32)",
                "(128, 256)",
                "(512, 1024)"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "9b6487ae3da5888aed4abbc9840c24efa7c9f770610ba57f73dc3fbc3710d2d3",
        "warmup_time": -1
    },
    "bench_manipulate.BroadcastArraysTo.time_broadcast_to": {
        "code": "class BroadcastArraysTo:\n    def time_broadcast_to(self, size, ndtype):\n        np.broadcast_to(self.xarg, (size, size))\n\n    def setup(self, size, ndtype):\n        self.rng = np.random.default_rng()\n        self.xarg = self.rng.random(size)\n        self.xarg = self.xarg.astype(ndtype)\n        if ndtype.startswith('complex'):\n            self.xarg += self.rng.random(1)*1j",
        "min_run_count": 2,
        "name": "bench_manipulate.BroadcastArraysTo.time_broadcast_to",
        "number": 0,
        "param_names": [
            "size",
            "ndtype"
        ],
        "params": [
            [
                "16",
                "64",
                "512"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "4bf0c2d55b83bcb0da84888be35090fb8dfdb6ca23e7f9968954c28e0f66f357",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateNestedArrays.time_concatenate_ax0": {
        "code": "class ConcatenateStackArrays:\n    def time_concatenate_ax0(self, size, narrays, ndtype):\n        np.concatenate(self.xarg, axis=0)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateNestedArrays.time_concatenate_ax0",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(1, 1)"
            ],
            [
                "1000",
                "100000"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "a434b48f9fb29116c216fcde02041f7c01e665dce682a308eb2bc69deee2df57",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateNestedArrays.time_concatenate_ax1": {
        "code": "class ConcatenateStackArrays:\n    def time_concatenate_ax1(self, size, narrays, ndtype):\n        np.concatenate(self.xarg, axis=1)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateNestedArrays.time_concatenate_ax1",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(1, 1)"
            ],
            [
                "1000",
                "100000"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "87a2f26023f62a5cde77925702168aeac0c8f564140e581d59ce6d2d3f850e5f",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateNestedArrays.time_stack_ax0": {
        "code": "class ConcatenateStackArrays:\n    def time_stack_ax0(self, size, narrays, ndtype):\n        np.stack(self.xarg, axis=0)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateNestedArrays.time_stack_ax0",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(1, 1)"
            ],
            [
                "1000",
                "100000"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "7c32f0afb10550e1eca0556bd78d6e6b422132ab8b9b54ca485826bf9b8dc25c",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateNestedArrays.time_stack_ax1": {
        "code": "class ConcatenateStackArrays:\n    def time_stack_ax1(self, size, narrays, ndtype):\n        np.stack(self.xarg, axis=1)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateNestedArrays.time_stack_ax1",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(1, 1)"
            ],
            [
                "1000",
                "100000"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "7b9ad04ef7e9ba0c582e8bea934d6804770dc17153e948e6ae42bf49a4084dec",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateStackArrays.time_concatenate_ax0": {
        "code": "class ConcatenateStackArrays:\n    def time_concatenate_ax0(self, size, narrays, ndtype):\n        np.concatenate(self.xarg, axis=0)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateStackArrays.time_concatenate_ax0",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(16, 32)",
                "(32, 64)"
            ],
            [
                "2",
                "5"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "a434b48f9fb29116c216fcde02041f7c01e665dce682a308eb2bc69deee2df57",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateStackArrays.time_concatenate_ax1": {
        "code": "class ConcatenateStackArrays:\n    def time_concatenate_ax1(self, size, narrays, ndtype):\n        np.concatenate(self.xarg, axis=1)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateStackArrays.time_concatenate_ax1",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(16, 32)",
                "(32, 64)"
            ],
            [
                "2",
                "5"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "87a2f26023f62a5cde77925702168aeac0c8f564140e581d59ce6d2d3f850e5f",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateStackArrays.time_stack_ax0": {
        "code": "class ConcatenateStackArrays:\n    def time_stack_ax0(self, size, narrays, ndtype):\n        np.stack(self.xarg, axis=0)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateStackArrays.time_stack_ax0",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(16, 32)",
                "(32, 64)"
            ],
            [
                "2",
                "5"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "7c32f0afb10550e1eca0556bd78d6e6b422132ab8b9b54ca485826bf9b8dc25c",
        "warmup_time": -1
    },
    "bench_manipulate.ConcatenateStackArrays.time_stack_ax1": {
        "code": "class ConcatenateStackArrays:\n    def time_stack_ax1(self, size, narrays, ndtype):\n        np.stack(self.xarg, axis=1)\n\n    def setup(self, shape, narrays, ndtype):\n        self.xarg = [np.random.ranf(shape[0]*shape[1]).reshape(shape)\n                     for x in range(narrays)]\n        self.xarg = [x.astype(ndtype) for x in self.xarg]\n        if ndtype.startswith('complex'):\n            [x + np.random.ranf(1)*1j for x in self.xarg]",
        "min_run_count": 2,
        "name": "bench_manipulate.ConcatenateStackArrays.time_stack_ax1",
        "number": 0,
        "param_names": [
            "shape",
            "narrays",
            "ndtype"
        ],
        "params": [
            [
                "(16, 32)",
                "(32, 64)"
            ],
            [
                "2",
                "5"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "7b9ad04ef7e9ba0c582e8bea934d6804770dc17153e948e6ae42bf49a4084dec",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_expand_dims": {
        "code": "class DimsManipulations:\n    def time_expand_dims(self, shape):\n        np.expand_dims(self.xarg, axis=1)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_expand_dims",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "c55c26b0456e8dbf0810111d4d994e34106112c3f6d52850e99d9c63ad75a8dd",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_expand_dims_neg": {
        "code": "class DimsManipulations:\n    def time_expand_dims_neg(self, shape):\n        np.expand_dims(self.xarg, axis=-1)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_expand_dims_neg",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "8faa78e30cca7abcb9cfea6fa832f5220d51f0b7f6ad859b9b0842f6ed089f03",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_flip_all": {
        "code": "class DimsManipulations:\n    def time_flip_all(self, shape):\n        np.flip(self.xarg, axis=None)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_flip_all",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "29070a270894425482c395044c3451dc8cb1138b710f21b9b3af7451a2bbf7bb",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_flip_neg": {
        "code": "class DimsManipulations:\n    def time_flip_neg(self, shape):\n        np.flip(self.xarg, axis=-1)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_flip_neg",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "83497392cf6e1dfd70b36b0cf433c43c5584e3759204db59ce957a208341151a",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_flip_one": {
        "code": "class DimsManipulations:\n    def time_flip_one(self, shape):\n        np.flip(self.xarg, axis=1)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_flip_one",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "70778a71dba44032e545217915a604aa1552c6436b0cb2a2f64916f069da4dd3",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_moveaxis": {
        "code": "class DimsManipulations:\n    def time_moveaxis(self, shape):\n        np.moveaxis(self.xarg, [0, 1], [-1, -2])\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_moveaxis",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "ea8621ee930309e2d8000183572bc84cd7911403bd78fc0daa180c89b3083fcb",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_reshape": {
        "code": "class DimsManipulations:\n    def time_reshape(self, shape):\n        np.reshape(self.xarg, self.reshaped)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_reshape",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "99ddfc58bc06d2bc816d50983e5750410cb38a09155439aadc017d7b057d9e2f",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_roll": {
        "code": "class DimsManipulations:\n    def time_roll(self, shape):\n        np.roll(self.xarg, 3)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_roll",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "5e7693d2f73bc8878edd95e1db332197c09fe6abe41e7ded81b8992235bbe845",
        "warmup_time": -1
    },
    "bench_manipulate.DimsManipulations.time_squeeze_dims": {
        "code": "class DimsManipulations:\n    def time_squeeze_dims(self, shape):\n        np.squeeze(self.xarg)\n\n    def setup(self, shape):\n        self.xarg = np.ones(shape=shape)\n        self.reshaped = deque(shape)\n        self.reshaped.rotate(1)\n        self.reshaped = tuple(self.reshaped)",
        "min_run_count": 2,
        "name": "bench_manipulate.DimsManipulations.time_squeeze_dims",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(2, 1, 4)",
                "(2, 1)",
                "(5, 2, 3, 1)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "dd9749fc93e17b45cb0401908219acb5dd16be09d0c2e7fb8c7feb9a8257954c",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_broadcast_to_duck": {
        "code": "class ArrayFunction:\n    def time_mock_broadcast_to_duck(self):\n        mock_broadcast_to(self.duck_array, ())\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_broadcast_to_duck",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b54211444ccedb1ab418dbbf6ec0f6a2ef4262f33dff86946a325e943e80ba0e",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_broadcast_to_numpy": {
        "code": "class ArrayFunction:\n    def time_mock_broadcast_to_numpy(self):\n        mock_broadcast_to(self.numpy_array, ())\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_broadcast_to_numpy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a77448f26c942ff1b0caa4cfa8e496e7f3b84342a4b3b798fadfde02460e4a7a",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_concatenate_duck": {
        "code": "class ArrayFunction:\n    def time_mock_concatenate_duck(self):\n        mock_concatenate(self.duck_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_concatenate_duck",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ca0f8a5a984c328b123d685cd3abebcfe69e74236884e9ae936604992f36247a",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_concatenate_many": {
        "code": "class ArrayFunction:\n    def time_mock_concatenate_many(self):\n        mock_concatenate(self.many_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_concatenate_many",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d63644407e7bb0c62ecd497191be5179221a5471d2679821ab9cd51e58e33b81",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_concatenate_mixed": {
        "code": "class ArrayFunction:\n    def time_mock_concatenate_mixed(self):\n        mock_concatenate(self.mixed_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_concatenate_mixed",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f0f836ffe9cd3cd7558defd3fcf150b87fed04847e82126cb3d0be71cf1db5d0",
        "warmup_time": -1
    },
    "bench_overrides.ArrayFunction.time_mock_concatenate_numpy": {
        "code": "class ArrayFunction:\n    def time_mock_concatenate_numpy(self):\n        mock_concatenate(self.numpy_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]",
        "min_run_count": 2,
        "name": "bench_overrides.ArrayFunction.time_mock_concatenate_numpy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ba531ff260ae0e34362db5e75dc2787f752347a622d2ac57279a05124ea3c43a",
        "warmup_time": -1
    },
    "bench_polynomial.Polynomial.time_polynomial_addition": {
        "code": "class Polynomial:\n    def time_polynomial_addition(self):\n        _ = self.polynomial_degree2 + self.polynomial_degree2\n\n    def setup(self):\n        self.polynomial_degree2 = np.polynomial.Polynomial(np.array([1, 2]))\n        self.array3 = np.linspace(0, 1, 3)\n        self.array1000 = np.linspace(0, 1, 10_000)\n        self.float64 = np.float64(1.0)",
        "min_run_count": 2,
        "name": "bench_polynomial.Polynomial.time_polynomial_addition",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "892eccb104b52f6ba1e91cd62fbbc124dad24982af96f28767a85a805183a5d3",
        "warmup_time": -1
    },
    "bench_polynomial.Polynomial.time_polynomial_evaluation_array_1000": {
        "code": "class Polynomial:\n    def time_polynomial_evaluation_array_1000(self):\n        self.polynomial_degree2(self.array1000)\n\n    def setup(self):\n        self.polynomial_degree2 = np.polynomial.Polynomial(np.array([1, 2]))\n        self.array3 = np.linspace(0, 1, 3)\n        self.array1000 = np.linspace(0, 1, 10_000)\n        self.float64 = np.float64(1.0)",
        "min_run_count": 2,
        "name": "bench_polynomial.Polynomial.time_polynomial_evaluation_array_1000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4fec6d5f3d82cb401fde9ece5147b1fe478c86294988e244bce97fa8ce9b2a66",
        "warmup_time": -1
    },
    "bench_polynomial.Polynomial.time_polynomial_evaluation_array_3": {
        "code": "class Polynomial:\n    def time_polynomial_evaluation_array_3(self):\n        self.polynomial_degree2(self.array3)\n\n    def setup(self):\n        self.polynomial_degree2 = np.polynomial.Polynomial(np.array([1, 2]))\n        self.array3 = np.linspace(0, 1, 3)\n        self.array1000 = np.linspace(0, 1, 10_000)\n        self.float64 = np.float64(1.0)",
        "min_run_count": 2,
        "name": "bench_polynomial.Polynomial.time_polynomial_evaluation_array_3",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9ec61637fcc7e5ea2a7d67317797fb3c669a4cc0b3b4c457ef0c5d933b1e047c",
        "warmup_time": -1
    },
    "bench_polynomial.Polynomial.time_polynomial_evaluation_python_float": {
        "code": "class Polynomial:\n    def time_polynomial_evaluation_python_float(self):\n        self.polynomial_degree2(1.0)\n\n    def setup(self):\n        self.polynomial_degree2 = np.polynomial.Polynomial(np.array([1, 2]))\n        self.array3 = np.linspace(0, 1, 3)\n        self.array1000 = np.linspace(0, 1, 10_000)\n        self.float64 = np.float64(1.0)",
        "min_run_count": 2,
        "name": "bench_polynomial.Polynomial.time_polynomial_evaluation_python_float",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2be5b0fbc156bbbb0cb78178734281dacfb0bc7a1ad9ec7f7d7eac5d3cb16085",
        "warmup_time": -1
    },
    "bench_polynomial.Polynomial.time_polynomial_evaluation_scalar": {
        "code": "class Polynomial:\n    def time_polynomial_evaluation_scalar(self):\n        self.polynomial_degree2(self.float64)\n\n    def setup(self):\n        self.polynomial_degree2 = np.polynomial.Polynomial(np.array([1, 2]))\n        self.array3 = np.linspace(0, 1, 3)\n        self.array1000 = np.linspace(0, 1, 10_000)\n        self.float64 = np.float64(1.0)",
        "min_run_count": 2,
        "name": "bench_polynomial.Polynomial.time_polynomial_evaluation_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c75ea46a7812ddddbbee94eced9ada02f227835aabe46d2f404092f0a86e1cc2",
        "warmup_time": -1
    },
    "bench_random.Bounded.time_bounded": {
        "code": "class Bounded:\n    def time_bounded(self, bitgen, args):\n            \"\"\"\n            Timer for 8-bit bounded values.\n    \n            Parameters (packed as args)\n            ----------\n            dt : {uint8, uint16, uint32, unit64}\n                output dtype\n            max : int\n                Upper bound for range. Lower is always 0.  Must be <= 2**bits.\n            \"\"\"\n            dt, max = args\n            if bitgen == 'numpy':\n                self.rg.randint(0, max + 1, nom_size, dtype=dt)\n            else:\n                self.rg.integers(0, max + 1, nom_size, dtype=dt)\n\n    def setup(self, bitgen, args):\n        seed = 707250673\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState(seed)\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)(seed))\n        self.rg.random()",
        "min_run_count": 2,
        "name": "bench_random.Bounded.time_bounded",
        "number": 0,
        "param_names": [
            "rng",
            "dt_max"
        ],
        "params": [
            [
                "'PCG64'",
                "'MT19937'",
                "'Philox'",
                "'SFC64'",
                "'numpy'"
            ],
            [
                "[<class 'numpy.uint8'>, 95]",
                "[<class 'numpy.uint8'>, 64]",
                "[<class 'numpy.uint8'>, 127]",
                "[<class 'numpy.uint16'>, 95]",
                "[<class 'numpy.uint16'>, 1024]",
                "[<class 'numpy.uint16'>, 1535]",
                "[<class 'numpy.uint16'>, 2047]",
                "[<class 'numpy.uint32'>, 1024]",
                "[<class 'numpy.uint32'>, 1535]",
                "[<class 'numpy.uint32'>, 2047]",
                "[<class 'numpy.uint64'>, 95]",
                "[<class 'numpy.uint64'>, 1024]",
                "[<class 'numpy.uint64'>, 1535]",
                "[<class 'numpy.uint64'>, 2047]"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "275527baec3411b17b7ef6bd248a513c53b9ffc7e999e2d3b8bd9197dc2d73a1",
        "warmup_time": -1
    },
    "bench_random.Choice.time_choice": {
        "code": "class Choice:\n    def time_choice(self, v):\n        self.rng.choice(self.a, 1000, replace=False)\n\n    def setup(self, v):\n        self.a = np.arange(v)\n        self.rng = np.random.default_rng()",
        "min_run_count": 2,
        "name": "bench_random.Choice.time_choice",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "1000.0",
                "1000000.0",
                "100000000.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "732a2a02157fac586fed5ed7e5cb87b3f922e3ee957fac07cc8a392d51f1e462",
        "warmup_time": -1
    },
    "bench_random.Choice.time_legacy_choice": {
        "code": "class Choice:\n    def time_legacy_choice(self, v):\n        np.random.choice(self.a, 1000, replace=False)\n\n    def setup(self, v):\n        self.a = np.arange(v)\n        self.rng = np.random.default_rng()",
        "min_run_count": 2,
        "name": "bench_random.Choice.time_legacy_choice",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "1000.0",
                "1000000.0",
                "100000000.0"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f8ea1e2859fc2421cf7aafc0c6f30d0342781a578958dbadfeeb1cfc31cf6cf1",
        "warmup_time": -1
    },
    "bench_random.Permutation.time_permutation_1d": {
        "code": "class Permutation:\n    def time_permutation_1d(self):\n        np.random.permutation(self.a_1d)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))",
        "min_run_count": 2,
        "name": "bench_random.Permutation.time_permutation_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "551dd96381ce6ea1af2f4261ae7b78bb04024222f86e42dc477bced10c5d3326",
        "warmup_time": -1
    },
    "bench_random.Permutation.time_permutation_2d": {
        "code": "class Permutation:\n    def time_permutation_2d(self):\n        np.random.permutation(self.a_2d)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))",
        "min_run_count": 2,
        "name": "bench_random.Permutation.time_permutation_2d",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "afbad8cd57abad2c145db591d5d673799f4702d837eb9c1fa2f69c5c853fe526",
        "warmup_time": -1
    },
    "bench_random.Permutation.time_permutation_int": {
        "code": "class Permutation:\n    def time_permutation_int(self):\n        np.random.permutation(self.n)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))",
        "min_run_count": 2,
        "name": "bench_random.Permutation.time_permutation_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "71e1c9cf4d468f4c66f76d7a4215275d590d638c56a84ce00a9da324d7d79818",
        "warmup_time": -1
    },
    "bench_random.RNG.time_32bit": {
        "code": "class RNG:\n    def time_32bit(self, bitgen):\n        min, max = self.uint32info.min, self.uint32info.max\n        if bitgen == 'numpy':\n            self.rg.randint(min, max + 1, nom_size, dtype=np.uint32)\n        else:\n            self.rg.integers(min, max + 1, nom_size, dtype=np.uint32)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)",
        "min_run_count": 2,
        "name": "bench_random.RNG.time_32bit",
        "number": 0,
        "param_names": [
            "rng"
        ],
        "params": [
            [
                "'PCG64'",
                "'MT19937'",
                "'Philox'",
                "'SFC64'",
                "'numpy'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cb6866d2a229860446d329ed86cec74da9f3f495d544006e29dba8f0eb9a2a29",
        "warmup_time": -1
    },
    "bench_random.RNG.time_64bit": {
        "code": "class RNG:\n    def time_64bit(self, bitgen):\n        min, max = self.uint64info.min, self.uint64info.max\n        if bitgen == 'numpy':\n            self.rg.randint(min, max + 1, nom_size, dtype=np.uint64)\n        else:\n            self.rg.integers(min, max + 1, nom_size, dtype=np.uint64)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)",
        "min_run_count": 2,
        "name": "bench_random.RNG.time_64bit",
        "number": 0,
        "param_names": [
            "rng"
        ],
        "params": [
            [
                "'PCG64'",
                "'MT19937'",
                "'Philox'",
                "'SFC64'",
                "'numpy'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f427158e9352900d3a4249235778210c55419c9a6abd475fba10b12a612f62cc",
        "warmup_time": -1
    },
    "bench_random.RNG.time_normal_zig": {
        "code": "class RNG:\n    def time_normal_zig(self, bitgen):\n        self.rg.standard_normal(nom_size)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)",
        "min_run_count": 2,
        "name": "bench_random.RNG.time_normal_zig",
        "number": 0,
        "param_names": [
            "rng"
        ],
        "params": [
            [
                "'PCG64'",
                "'MT19937'",
                "'Philox'",
                "'SFC64'",
                "'numpy'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b07ff35f63c9be7b9129a247a6f3b90d3209858b607b91e42b0be9c75a7cdf2f",
        "warmup_time": -1
    },
    "bench_random.RNG.time_raw": {
        "code": "class RNG:\n    def time_raw(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg.random_integers(self.int32info.max, size=nom_size)\n        else:\n            self.rg.integers(self.int32info.max, size=nom_size, endpoint=True)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)",
        "min_run_count": 2,
        "name": "bench_random.RNG.time_raw",
        "number": 0,
        "param_names": [
            "rng"
        ],
        "params": [
            [
                "'PCG64'",
                "'MT19937'",
                "'Philox'",
                "'SFC64'",
                "'numpy'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9a10bd242f667f726dd0b180cc185c6eb1a96cc178b96a6f905d269b2f8641c6",
        "warmup_time": -1
    },
    "bench_random.Randint.time_randint_fast": {
        "code": "class Randint:\n    def time_randint_fast(self):\n        \"\"\"Compare to uint32 below\"\"\"\n        np.random.randint(0, 2**30, size=10**5)",
        "min_run_count": 2,
        "name": "bench_random.Randint.time_randint_fast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bb8c6b342d125e6ce85eba74f81e9a3f69eb3a1f4948921a73b680d3ea4f312e",
        "warmup_time": -1
    },
    "bench_random.Randint.time_randint_slow": {
        "code": "class Randint:\n    def time_randint_slow(self):\n        \"\"\"Compare to uint32 below\"\"\"\n        np.random.randint(0, 2**30 + 1, size=10**5)",
        "min_run_count": 2,
        "name": "bench_random.Randint.time_randint_slow",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "97dcc24881c776455f5c6a04bec764909ac9a0e4f7cfde6413f8d60a487adbc5",
        "warmup_time": -1
    },
    "bench_random.Randint_dtype.time_randint_fast": {
        "code": "class Randint_dtype:\n    def time_randint_fast(self, name):\n        high = self.high[name]\n        np.random.randint(0, high, size=10**5, dtype=name)\n\n    def setup(self, name):\n        from numpy.lib import NumpyVersion\n        if NumpyVersion(np.__version__) < '1.11.0.dev0':\n            raise NotImplementedError",
        "min_run_count": 2,
        "name": "bench_random.Randint_dtype.time_randint_fast",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'bool'",
                "'uint8'",
                "'uint16'",
                "'uint32'",
                "'uint64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "686cd267595db36e1a5b21a65b9f0a77efb9cd65c4b1b7f631b7ffe955087d2b",
        "warmup_time": -1
    },
    "bench_random.Randint_dtype.time_randint_slow": {
        "code": "class Randint_dtype:\n    def time_randint_slow(self, name):\n        high = self.high[name]\n        np.random.randint(0, high + 1, size=10**5, dtype=name)\n\n    def setup(self, name):\n        from numpy.lib import NumpyVersion\n        if NumpyVersion(np.__version__) < '1.11.0.dev0':\n            raise NotImplementedError",
        "min_run_count": 2,
        "name": "bench_random.Randint_dtype.time_randint_slow",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'bool'",
                "'uint8'",
                "'uint16'",
                "'uint32'",
                "'uint64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5288dc43a24dc0ad0085d813bc9c7f1501cff277adbffe869256718c92d76bbd",
        "warmup_time": -1
    },
    "bench_random.Random.time_rng": {
        "code": "class Random:\n    def time_rng(self, name):\n        self.func(*self.params)\n\n    def setup(self, name):\n        items = name.split()\n        name = items.pop(0)\n        params = [float(x) for x in items]\n    \n        self.func = getattr(np.random, name)\n        self.params = tuple(params) + ((100, 100),)",
        "min_run_count": 2,
        "name": "bench_random.Random.time_rng",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "'normal'",
                "'uniform'",
                "'weibull 1'",
                "'binomial 10 0.5'",
                "'poisson 10'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "20d7c6d641e664676dba02e39f4358735344639b5c0798301d8702c6d4b0cb1f",
        "warmup_time": -1
    },
    "bench_random.Shuffle.time_100000": {
        "code": "class Shuffle:\n    def time_100000(self):\n        np.random.shuffle(self.a)\n\n    def setup(self):\n        self.a = np.arange(100000)",
        "min_run_count": 2,
        "name": "bench_random.Shuffle.time_100000",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "008b63ed906c93eff862ba9a6aad85a0ed290deb009fa1085447a66b23e8d717",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromarrays_formats_as_list": {
        "code": "class Records:\n    def time_fromarrays_formats_as_list(self):\n        np._core.records.fromarrays(self.arrays, formats=self.formats)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromarrays_formats_as_list",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cf78f8ec1b060f7a22986ea0b2afeaf5f801bf788c6000fcdb89ea00c6063af3",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromarrays_formats_as_string": {
        "code": "class Records:\n    def time_fromarrays_formats_as_string(self):\n        np._core.records.fromarrays(self.arrays, formats=self.formats_str)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromarrays_formats_as_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "70d3c58788e97465026505470ff1d462e7a303d486050149fe3068358cc93d4a",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromarrays_w_dtype": {
        "code": "class Records:\n    def time_fromarrays_w_dtype(self):\n        np._core.records.fromarrays(self.arrays, dtype=self.dtype_)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromarrays_w_dtype",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7841a34161cfe8acbd4f67d9f0566238c6f5be3a03a8479aca8834062ecc57ab",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromarrays_wo_dtype": {
        "code": "class Records:\n    def time_fromarrays_wo_dtype(self):\n        np._core.records.fromarrays(self.arrays)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromarrays_wo_dtype",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c7e04f33d24b9bd43d0e3f161871fe60d20dd8e9c2c50307c12a406a66a8a733",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromstring_formats_as_list": {
        "code": "class Records:\n    def time_fromstring_formats_as_list(self):\n        np._core.records.fromstring(self.buffer, formats=self.formats)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromstring_formats_as_list",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8d6ad959d03eeb837d44b0f72016e88d210e0d67eeb6a1bfdbf2ee31c377a6bc",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromstring_formats_as_string": {
        "code": "class Records:\n    def time_fromstring_formats_as_string(self):\n        np._core.records.fromstring(self.buffer, formats=self.formats_str)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromstring_formats_as_string",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "92b000b098dcf745221977e63c7d2f66a8ced9593494099c97ac017f48cb4fd6",
        "warmup_time": -1
    },
    "bench_records.Records.time_fromstring_w_dtype": {
        "code": "class Records:\n    def time_fromstring_w_dtype(self):\n        np._core.records.fromstring(self.buffer, dtype=self.dtype_)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number",
        "min_run_count": 2,
        "name": "bench_records.Records.time_fromstring_w_dtype",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "02e356971de0062771369ce4929f077a49be6307fc329d46ef6fe914421eff9b",
        "warmup_time": -1
    },
    "bench_reduce.AddReduce.time_axis_0": {
        "code": "class AddReduce:\n    def time_axis_0(self):\n        [np.add.reduce(a, axis=0) for a in self.squares]\n\n    def setup(self):\n        self.squares = get_squares().values()",
        "min_run_count": 2,
        "name": "bench_reduce.AddReduce.time_axis_0",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2af9934f0fbbc8408edad22dfb037bd0861b919664055e5fe609f4058bffd1d9",
        "warmup_time": -1
    },
    "bench_reduce.AddReduce.time_axis_1": {
        "code": "class AddReduce:\n    def time_axis_1(self):\n        [np.add.reduce(a, axis=1) for a in self.squares]\n\n    def setup(self):\n        self.squares = get_squares().values()",
        "min_run_count": 2,
        "name": "bench_reduce.AddReduce.time_axis_1",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9e926386f8f433cfbcbea78e95c4f2cb3755951748b965430ab5e407be5d4b66",
        "warmup_time": -1
    },
    "bench_reduce.AddReduceSeparate.time_reduce": {
        "code": "class AddReduceSeparate:\n    def time_reduce(self, axis, typename):\n        np.add.reduce(self.a, axis=axis)\n\n    def setup(self, axis, typename):\n        self.a = get_squares()[typename]",
        "min_run_count": 2,
        "name": "bench_reduce.AddReduceSeparate.time_reduce",
        "number": 0,
        "param_names": [
            "axis",
            "type"
        ],
        "params": [
            [
                "0",
                "1"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9fe950161a3a7c6883be4205a98ad6f3b268adcb3448bb900588c9a05f1b4d41",
        "warmup_time": -1
    },
    "bench_reduce.AnyAll.time_all_fast": {
        "code": "class AnyAll:\n    def time_all_fast(self):\n        self.zeros.all()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)",
        "min_run_count": 2,
        "name": "bench_reduce.AnyAll.time_all_fast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "337055e8376d23b58323da5853a1ce18e7025e49c95efd41d01732d37a916411",
        "warmup_time": -1
    },
    "bench_reduce.AnyAll.time_all_slow": {
        "code": "class AnyAll:\n    def time_all_slow(self):\n        self.ones.all()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)",
        "min_run_count": 2,
        "name": "bench_reduce.AnyAll.time_all_slow",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9e00fb89e58c9b2b417aa7e9a7920769076051c19ff0c466ae4aab094bdb5dc3",
        "warmup_time": -1
    },
    "bench_reduce.AnyAll.time_any_fast": {
        "code": "class AnyAll:\n    def time_any_fast(self):\n        self.ones.any()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)",
        "min_run_count": 2,
        "name": "bench_reduce.AnyAll.time_any_fast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1bed9465b7afde4e6e437837f60b2b4315f05e9186392b2df64a3ecfd4fb8b98",
        "warmup_time": -1
    },
    "bench_reduce.AnyAll.time_any_slow": {
        "code": "class AnyAll:\n    def time_any_slow(self):\n        self.zeros.any()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)",
        "min_run_count": 2,
        "name": "bench_reduce.AnyAll.time_any_slow",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fdb7e7815fcaa4c4c0a8613bdd1f28b855d03f3732f123a144a613fcaa23d01f",
        "warmup_time": -1
    },
    "bench_reduce.ArgMax.time_argmax": {
        "code": "class ArgMax:\n    def time_argmax(self, dtype):\n        np.argmax(self.d)\n\n    def setup(self, dtype):\n        self.d = np.zeros(200000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_reduce.ArgMax.time_argmax",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'bool'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2843a21fe3f8f99974c2c8e3ea2c53595d3246781016dfc14abd6116d720ba5e",
        "warmup_time": -1
    },
    "bench_reduce.ArgMin.time_argmin": {
        "code": "class ArgMin:\n    def time_argmin(self, dtype):\n        np.argmin(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(200000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_reduce.ArgMin.time_argmin",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'bool'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d27ef6416f131ec01126aa5533d3eb7c800f5685ce71066fc26f93b281289d1d",
        "warmup_time": -1
    },
    "bench_reduce.FMinMax.time_max": {
        "code": "class FMinMax:\n    def time_max(self, dtype):\n        np.fmax.reduce(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_reduce.FMinMax.time_max",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3fedfd780a61cfbd72db31664ca87b48f7046888915accac1229b660d9226fb0",
        "warmup_time": -1
    },
    "bench_reduce.FMinMax.time_min": {
        "code": "class FMinMax:\n    def time_min(self, dtype):\n        np.fmin.reduce(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_reduce.FMinMax.time_min",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "28ddb46378c2fad1fdfb475f928b1e3763f86a66ae792daabe87f2828c53db81",
        "warmup_time": -1
    },
    "bench_reduce.SmallReduction.time_small": {
        "code": "class SmallReduction:\n    def time_small(self):\n        np.sum(self.d)\n\n    def setup(self):\n        self.d = np.ones(100, dtype=np.float32)",
        "min_run_count": 2,
        "name": "bench_reduce.SmallReduction.time_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6c036bc421f0fb669164ceb2814d8765d6f3a6c7c38f5e2e55a3fc00945c9468",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_max": {
        "code": "class StatsReductions:\n    def time_max(self, dtype):\n        np.max(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_max",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "998ddcde0de9eb046284e93c72d2324973e274e56d7293d2d150ede022af792b",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_mean": {
        "code": "class StatsReductions:\n    def time_mean(self, dtype):\n        np.mean(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_mean",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9a035d8a7e5578d9aa889ad7ff5373d58d3eca06201fcddcf8fbcc6381ea9158",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_min": {
        "code": "class StatsReductions:\n    def time_min(self, dtype):\n        np.min(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_min",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c53ebf37802eb285120e28cb7b39f6a3f5f8e9125e20a5b540f90a7707033452",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_prod": {
        "code": "class StatsReductions:\n    def time_prod(self, dtype):\n        np.prod(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_prod",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "78790ac0a06dc6fef3eb9d85c64b273ee47beb0aa6b2adf58627c6738625f0e3",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_std": {
        "code": "class StatsReductions:\n    def time_std(self, dtype):\n        np.std(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_std",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "25fe3d6bb1b2d4955df15a03dfa7074c6eaca6e11a1c316a14c0582c32684f3c",
        "warmup_time": -1
    },
    "bench_reduce.StatsReductions.time_var": {
        "code": "class StatsReductions:\n    def time_var(self, dtype):\n        np.var(self.data)\n\n    def setup(self, dtype):\n        self.data = np.ones(200, dtype=dtype)\n        if dtype.startswith('complex'):\n            self.data = self.data * self.data.T*1j",
        "min_run_count": 2,
        "name": "bench_reduce.StatsReductions.time_var",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "'int64'",
                "'uint64'",
                "'float32'",
                "'float64'",
                "'complex64'",
                "'bool_'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1a39d8827648d2a8858f48558c22d334474cacb75cc390a1df431c98d91ea51c",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_abs": {
        "code": "class ScalarMath:\n    def time_abs(self, typename):\n        n = self.num\n        res = abs(abs(abs(abs(abs(abs(abs(abs(abs(abs(n))))))))))\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_abs",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7591b0e037d086027d27593dc93810522765dd7ad6ba7bf0e4abd3a4bfbd9c09",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_add_int32_other": {
        "code": "class ScalarMath:\n    def time_add_int32_other(self, typename):\n        # Some mixed cases are fast, some are slow, this documents these\n        # differences.  (When writing, it was fast if the type of the result\n        # is one of the inputs.)\n        int32 = self.int32\n        other = self.num\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_add_int32_other",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cf0cc872be896171e60522d76cad520207b9dda6c66c74b1ea587f865e8b3c3b",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_add_int32arr_and_other": {
        "code": "class ScalarMath:\n    def time_add_int32arr_and_other(self, typename):\n        # `arr + scalar` hits the normal ufunc (array) paths.\n        int32 = self.int32arr\n        other = self.num\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_add_int32arr_and_other",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a3989983f83f427ef4dfdf79504251c6d93fda93c4fda51b196ddc57a66f37fc",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_add_other_and_int32arr": {
        "code": "class ScalarMath:\n    def time_add_other_and_int32arr(self, typename):\n        # `scalar + arr` at some point hit scalar paths in some cases, and\n        # these paths could be optimized more easily\n        int32 = self.int32arr\n        other = self.num\n        other + int32\n        other + int32\n        other + int32\n        other + int32\n        other + int32\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_add_other_and_int32arr",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "baba6c5e7b280c73a4c9679807b7aeff690ddf89e5f02bd480dde007c5675bf6",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_addition": {
        "code": "class ScalarMath:\n    def time_addition(self, typename):\n        n = self.num\n        res = n + n + n + n + n + n + n + n + n + n\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_addition",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c6acd8c382e717a438cd22d4839a2e81832b6976d1cb5bf72c60fe11d51e096e",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_addition_pyint": {
        "code": "class ScalarMath:\n    def time_addition_pyint(self, typename):\n        n = self.num\n        res = n + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_addition_pyint",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f0cd5a595ffe5e3294dda632d0c88da1a5683fefef50109bd123ceef32ec2b50",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_multiplication": {
        "code": "class ScalarMath:\n    def time_multiplication(self, typename):\n        n = self.num\n        res = n * n * n * n * n * n * n * n * n * n\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_multiplication",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ba5b9f9117a1a7b3b77dff2afef34fac8968c6447e7c743ae8ed26f80935e95a",
        "warmup_time": -1
    },
    "bench_scalar.ScalarMath.time_power_of_two": {
        "code": "class ScalarMath:\n    def time_power_of_two(self, typename):\n        n = self.num\n        res = n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarMath.time_power_of_two",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "383b216c2291472c6063c61807295eda2a0b5e7b2378effbfe287b1b347249f6",
        "warmup_time": -1
    },
    "bench_scalar.ScalarStr.time_str_repr": {
        "code": "class ScalarStr:\n    def time_str_repr(self, typename):\n        res = [str(x) for x in self.a]\n\n    def setup(self, typename):\n        self.a = np.array([100] * 100, dtype=typename)",
        "min_run_count": 2,
        "name": "bench_scalar.ScalarStr.time_str_repr",
        "number": 0,
        "param_names": [
            "type"
        ],
        "params": [
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "42e5f173e966738fa718083de971676234dc4b04f594b164b5343225e3cd7627",
        "warmup_time": -1
    },
    "bench_shape_base.AtLeast1D.time_atleast_1d": {
        "code": "class AtLeast1D:\n    def time_atleast_1d(self):\n        np.atleast_1d(self.x, self.x, self.x)\n\n    def setup(self):\n        self.x = np.array([1, 2, 3])\n        self.zero_d = np.float64(1.)",
        "min_run_count": 2,
        "name": "bench_shape_base.AtLeast1D.time_atleast_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "718d028aec2ee063b2a6ffa48d69fdb99fc37ce35ae1cf804b8c3a6177ff203e",
        "warmup_time": -1
    },
    "bench_shape_base.AtLeast1D.time_atleast_1d_reshape": {
        "code": "class AtLeast1D:\n    def time_atleast_1d_reshape(self):\n        np.atleast_1d(self.zero_d, self.zero_d, self.zero_d)\n\n    def setup(self):\n        self.x = np.array([1, 2, 3])\n        self.zero_d = np.float64(1.)",
        "min_run_count": 2,
        "name": "bench_shape_base.AtLeast1D.time_atleast_1d_reshape",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e532d14e69ac6c7237ebc09f3d3994460a86b397f4c996123db4e8954987bbe7",
        "warmup_time": -1
    },
    "bench_shape_base.AtLeast1D.time_atleast_1d_single_argument": {
        "code": "class AtLeast1D:\n    def time_atleast_1d_single_argument(self):\n        np.atleast_1d(self.x)\n\n    def setup(self):\n        self.x = np.array([1, 2, 3])\n        self.zero_d = np.float64(1.)",
        "min_run_count": 2,
        "name": "bench_shape_base.AtLeast1D.time_atleast_1d_single_argument",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4bf5fd6200ee3d687cb329b11a752ed991918351aa3b855e6182c540850890b0",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_3d": {
        "code": "class Block3D:\n    def time_3d(self, n, mode):\n        if mode == 'block':\n            np.block(self.block)\n        else:  # mode == 'copy'\n            [arr.copy() for arr in self.arr_list]\n\n    def setup(self, n, mode):\n        # Slow setup method: hence separated from the others above\n        self.a000 = np.ones((2 * n, 2 * n, 2 * n), int) * 1\n    \n        self.a100 = np.ones((3 * n, 2 * n, 2 * n), int) * 2\n        self.a010 = np.ones((2 * n, 3 * n, 2 * n), int) * 3\n        self.a001 = np.ones((2 * n, 2 * n, 3 * n), int) * 4\n    \n        self.a011 = np.ones((2 * n, 3 * n, 3 * n), int) * 5\n        self.a101 = np.ones((3 * n, 2 * n, 3 * n), int) * 6\n        self.a110 = np.ones((3 * n, 3 * n, 2 * n), int) * 7\n    \n        self.a111 = np.ones((3 * n, 3 * n, 3 * n), int) * 8\n    \n        self.block = [\n            [\n                [self.a000, self.a001],\n                [self.a010, self.a011],\n            ],\n            [\n                [self.a100, self.a101],\n                [self.a110, self.a111],\n            ]\n        ]\n        self.arr_list = [a\n                         for two_d in self.block\n                         for one_d in two_d\n                         for a in one_d]",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_3d",
        "number": 0,
        "param_names": [
            "n",
            "mode"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ],
            [
                "'block'",
                "'copy'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b9a48960b73fb3f85bfc2dc0e571c65492e2e23f6ba46efdbaa83c229a840ed3",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_block_complicated": {
        "code": "class Block:\n    def time_block_complicated(self, n):\n        np.block([[self.one_2d, self.two_2d],\n                  [self.three_2d],\n                  [self.four_1d],\n                  [self.five_0d, self.six_1d],\n                  [self.zero_2d]])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_block_complicated",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f5020e81ec4b44cc8c43385d45447eb00773324ed075f3e140a83e6deea1b5b1",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_block_simple_column_wise": {
        "code": "class Block:\n    def time_block_simple_column_wise(self, n):\n        np.block([[self.a_2d], [self.b_2d]])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_block_simple_column_wise",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ace4adce497cb59167431a3cb0e9336e9a4ca74c5a028728f072cb377034afac",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_block_simple_row_wise": {
        "code": "class Block:\n    def time_block_simple_row_wise(self, n):\n        np.block([self.a_2d, self.b_2d])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_block_simple_row_wise",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7e68cd3ac85d87ea0960b4e3480f3447d612752cc5da0d8e622d44883521fb9a",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_nested": {
        "code": "class Block:\n    def time_nested(self, n):\n        np.block([\n            [\n                np.block([\n                   [self.one],\n                   [self.three],\n                   [self.four]\n                ]),\n                self.two\n            ],\n            [self.five, self.six],\n            [self.zero]\n        ])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_nested",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "76a91fd4afc8a0e86b6afd79d5f3ea4ecd9fbbef884ae0500b470509e9e8b67e",
        "warmup_time": -1
    },
    "bench_shape_base.Block.time_no_lists": {
        "code": "class Block:\n    def time_no_lists(self, n):\n        np.block(1)\n        np.block(np.eye(3 * n))\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)",
        "min_run_count": 2,
        "name": "bench_shape_base.Block.time_no_lists",
        "number": 0,
        "param_names": [
            "size"
        ],
        "params": [
            [
                "1",
                "10",
                "100"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6bc26f65802cda859473d4bbdd7c111e5084ace7bd39cca0c9ca3aad06eee9ea",
        "warmup_time": -1
    },
    "bench_shape_base.Block2D.time_block2d": {
        "code": "class Block2D:\n    def time_block2d(self, shape, dtype, n_chunks):\n        np.block(self.block_list)\n\n    def setup(self, shape, dtype, n_chunks):\n    \n        self.block_list = [\n             [np.full(shape=[s//n_chunk for s, n_chunk in zip(shape, n_chunks)],\n                     fill_value=1, dtype=dtype) for _ in range(n_chunks[1])]\n            for _ in range(n_chunks[0])\n        ]",
        "min_run_count": 2,
        "name": "bench_shape_base.Block2D.time_block2d",
        "number": 0,
        "param_names": [
            "shape",
            "dtype",
            "n_chunks"
        ],
        "params": [
            [
                "(16, 16)",
                "(64, 64)",
                "(256, 256)",
                "(1024, 1024)"
            ],
            [
                "'uint8'",
                "'uint16'",
                "'uint32'",
                "'uint64'"
            ],
            [
                "(2, 2)",
                "(4, 4)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "93de8827eb35255e1f0daea4c5054d670f73b0c62c2cb54fc42a81e29c851ea8",
        "warmup_time": -1
    },
    "bench_shape_base.Kron.time_arr_kron": {
        "code": "class Kron:\n    def time_arr_kron(self):\n        np.kron(self.large_arr, self.large_arr)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.asmatrix(np.random.random((100, 100)))\n        self.scalar = 7",
        "min_run_count": 2,
        "name": "bench_shape_base.Kron.time_arr_kron",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "82c6ee81f8cf9275c1379f289c6dcf2b566211f0568ab4dd584a4dccdde75793",
        "warmup_time": -1
    },
    "bench_shape_base.Kron.time_mat_kron": {
        "code": "class Kron:\n    def time_mat_kron(self):\n        np.kron(self.large_mat, self.large_mat)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.asmatrix(np.random.random((100, 100)))\n        self.scalar = 7",
        "min_run_count": 2,
        "name": "bench_shape_base.Kron.time_mat_kron",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "71c7f5a56732bc67eea2e0f9d781f6fd9e8c1d05129cd6fd03c14cf16da3a0d4",
        "warmup_time": -1
    },
    "bench_shape_base.Kron.time_scalar_kron": {
        "code": "class Kron:\n    def time_scalar_kron(self):\n        np.kron(self.large_arr, self.scalar)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.asmatrix(np.random.random((100, 100)))\n        self.scalar = 7",
        "min_run_count": 2,
        "name": "bench_shape_base.Kron.time_scalar_kron",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ca45550436d14aa05dd6bce3f4dc64bc86b37bf360113650e6af3ab263cece7d",
        "warmup_time": -1
    },
    "bench_strings.StringComparisons.time_compare_different": {
        "code": "class StringComparisons:\n    def time_compare_different(self, shape, dtype, contig, operator):\n        self.operator(self.arr, self.arr_different)\n\n    def setup(self, shape, dtype, contig, operator):\n        self.arr = np.arange(np.prod(shape)).astype(dtype).reshape(shape)\n        self.arr_identical = self.arr.copy()\n        self.arr_different = self.arr[::-1].copy()\n    \n        if not contig:\n            self.arr = self.arr[..., ::2]\n            self.arr_identical = self.arr_identical[..., ::2]\n            self.arr_different = self.arr_different[..., ::2]\n    \n        self.operator = _OPERATORS[operator]",
        "min_run_count": 2,
        "name": "bench_strings.StringComparisons.time_compare_different",
        "number": 0,
        "param_names": [
            "shape",
            "dtype",
            "contig",
            "operator"
        ],
        "params": [
            [
                "100",
                "10000",
                "(1000, 20)"
            ],
            [
                "'U'",
                "'S'"
            ],
            [
                "True",
                "False"
            ],
            [
                "'=='",
                "'!='",
                "'<'",
                "'<='",
                "'>'",
                "'>='"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b18e3cc1b73c555958b266b870850fbd687b4b6f76ef8d91f4790b918360ddd3",
        "warmup_time": -1
    },
    "bench_strings.StringComparisons.time_compare_identical": {
        "code": "class StringComparisons:\n    def time_compare_identical(self, shape, dtype, contig, operator):\n        self.operator(self.arr, self.arr_identical)\n\n    def setup(self, shape, dtype, contig, operator):\n        self.arr = np.arange(np.prod(shape)).astype(dtype).reshape(shape)\n        self.arr_identical = self.arr.copy()\n        self.arr_different = self.arr[::-1].copy()\n    \n        if not contig:\n            self.arr = self.arr[..., ::2]\n            self.arr_identical = self.arr_identical[..., ::2]\n            self.arr_different = self.arr_different[..., ::2]\n    \n        self.operator = _OPERATORS[operator]",
        "min_run_count": 2,
        "name": "bench_strings.StringComparisons.time_compare_identical",
        "number": 0,
        "param_names": [
            "shape",
            "dtype",
            "contig",
            "operator"
        ],
        "params": [
            [
                "100",
                "10000",
                "(1000, 20)"
            ],
            [
                "'U'",
                "'S'"
            ],
            [
                "True",
                "False"
            ],
            [
                "'=='",
                "'!='",
                "'<'",
                "'<='",
                "'>'",
                "'>='"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0833c4a040b6064547dc2deefb71b873a918b57116d4bf24d8594d62213834c0",
        "warmup_time": -1
    },
    "bench_trim_zeros.TrimZeros.time_trim_zeros": {
        "code": "class TrimZeros:\n    def time_trim_zeros(self, dtype, size):\n        np.trim_zeros(self.array)\n\n    def setup(self, dtype, size):\n        n = size // 3\n        self.array = np.hstack([\n            np.zeros(n),\n            np.random.uniform(size=n),\n            np.zeros(n),\n        ]).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_trim_zeros.TrimZeros.time_trim_zeros",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "dtype('int64')",
                "dtype('float64')",
                "dtype('complex128')",
                "dtype('bool')"
            ],
            [
                "3000",
                "30000",
                "300000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "aa967874dea8e59b67e272fc23171647622694eafb5361945f785d17500097c3",
        "warmup_time": -1
    },
    "bench_ufunc.ArgParsing.time_add_arg_parsing": {
        "code": "class ArgParsing:\n    def time_add_arg_parsing(self, arg_pack):\n        np.add(*arg_pack.args, **arg_pack.kwargs)",
        "min_run_count": 2,
        "name": "bench_ufunc.ArgParsing.time_add_arg_parsing",
        "number": 0,
        "param_names": [
            "arg_kwarg"
        ],
        "params": [
            [
                "(array(1.), array(2.))",
                "(array(1.), array(2.), array(3.))",
                "(array(1.), array(2.), out=array(3.))",
                "(array(1.), array(2.), out=(array(3.),))",
                "(array(1.), array(2.), out=array(3.), subok=True, where=True)",
                "(array(1.), array(2.), subok=True)",
                "(array(1.), array(2.), subok=True, where=True)",
                "(array(1.), array(2.), array(3.), subok=True, where=True)"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.ArgParsingReduce.time_add_reduce_arg_parsing": {
        "code": "class ArgParsingReduce:\n    def time_add_reduce_arg_parsing(self, arg_pack):\n        np.add.reduce(*arg_pack.args, **arg_pack.kwargs)",
        "min_run_count": 2,
        "name": "bench_ufunc.ArgParsingReduce.time_add_reduce_arg_parsing",
        "number": 0,
        "param_names": [
            "arg_kwarg"
        ],
        "params": [
            [
                "(array([0., 1.]))",
                "(array([0., 1.]), 0)",
                "(array([0., 1.]), axis=0)",
                "(array([0., 1.]), 0, None)",
                "(array([0., 1.]), axis=0, dtype=None)",
                "(array([0., 1.]), 0, None, array(0.))",
                "(array([0., 1.]), axis=0, dtype=None, out=array(0.))",
                "(array([0., 1.]), out=array(0.))"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.ArrayFunctionDispatcher.time_afdn_types": {
        "code": "class ArrayFunctionDispatcher:\n    def time_afdn_types(self, ufuncname):\n        [self.afdn(*arg) for arg in self.args]\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.afdn = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.args = []\n        for _, aarg in get_squares_().items():\n            arg = (aarg,) * 1  # no nin\n            try:\n                self.afdn(*arg)\n            except TypeError:\n                continue\n            self.args.append(arg)",
        "min_run_count": 2,
        "name": "bench_ufunc.ArrayFunctionDispatcher.time_afdn_types",
        "number": 0,
        "param_names": [
            "func"
        ],
        "params": [
            [
                "'real'",
                "'round'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.At.time_maximum_at": {
        "code": "class At:\n    def time_maximum_at(self):\n        np.maximum.at(self.res, self.idx, self.vals)\n\n    def setup(self):\n        rng = np.random.default_rng(1)\n        self.vals = rng.random(10_000_000, dtype=np.float64)\n        self.idx = rng.integers(1000, size=10_000_000).astype(np.intp)\n        self.res = np.zeros(1000, dtype=self.vals.dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.At.time_maximum_at",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.At.time_sum_at": {
        "code": "class At:\n    def time_sum_at(self):\n        np.add.at(self.res, self.idx, self.vals)\n\n    def setup(self):\n        rng = np.random.default_rng(1)\n        self.vals = rng.random(10_000_000, dtype=np.float64)\n        self.idx = rng.integers(1000, size=10_000_000).astype(np.intp)\n        self.res = np.zeros(1000, dtype=self.vals.dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.At.time_sum_at",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBench.time_atan2": {
        "code": "class BinaryBench:\n    def time_atan2(self, dtype):\n        np.arctan2(self.a, self.b)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.rand(N).astype(dtype)\n        self.b = np.random.rand(N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBench.time_atan2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBench.time_pow": {
        "code": "class BinaryBench:\n    def time_pow(self, dtype):\n        np.power(self.a, self.b)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.rand(N).astype(dtype)\n        self.b = np.random.rand(N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBench.time_pow",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBench.time_pow_2": {
        "code": "class BinaryBench:\n    def time_pow_2(self, dtype):\n        np.power(self.a, 2.0)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.rand(N).astype(dtype)\n        self.b = np.random.rand(N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBench.time_pow_2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBench.time_pow_half": {
        "code": "class BinaryBench:\n    def time_pow_half(self, dtype):\n        np.power(self.a, 0.5)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.rand(N).astype(dtype)\n        self.b = np.random.rand(N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBench.time_pow_half",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBenchInteger.time_pow": {
        "code": "class BinaryBenchInteger:\n    def time_pow(self, dtype):\n        np.power(self.a, self.b)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.randint(20, size=N).astype(dtype)\n        self.b = np.random.randint(4, size=N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBenchInteger.time_pow",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBenchInteger.time_pow_five": {
        "code": "class BinaryBenchInteger:\n    def time_pow_five(self, dtype):\n        np.power(self.a, 5)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.randint(20, size=N).astype(dtype)\n        self.b = np.random.randint(4, size=N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBenchInteger.time_pow_five",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.BinaryBenchInteger.time_pow_two": {
        "code": "class BinaryBenchInteger:\n    def time_pow_two(self, dtype):\n        np.power(self.a, 2)\n\n    def setup(self, dtype):\n        N = 1000000\n        self.a = np.random.randint(20, size=N).astype(dtype)\n        self.b = np.random.randint(4, size=N).astype(dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.BinaryBenchInteger.time_pow_two",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Broadcast.time_broadcast": {
        "code": "class Broadcast:\n    def time_broadcast(self):\n        self.d - self.e\n\n    def setup(self):\n        self.d = np.ones((50000, 100), dtype=np.float64)\n        self.e = np.ones((100,), dtype=np.float64)",
        "min_run_count": 2,
        "name": "bench_ufunc.Broadcast.time_broadcast",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Custom.time_and_bool": {
        "code": "class Custom:\n    def time_and_bool(self):\n        (self.b & self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)",
        "min_run_count": 2,
        "name": "bench_ufunc.Custom.time_and_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Custom.time_and_bool_small": {
        "code": "class Custom:\n    def time_and_bool_small(self):\n        (self.b_small & self.b_small)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)",
        "min_run_count": 2,
        "name": "bench_ufunc.Custom.time_and_bool_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Custom.time_nonzero": {
        "code": "class Custom:\n    def time_nonzero(self):\n        np.nonzero(self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)",
        "min_run_count": 2,
        "name": "bench_ufunc.Custom.time_nonzero",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Custom.time_not_bool": {
        "code": "class Custom:\n    def time_not_bool(self):\n        (~self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)",
        "min_run_count": 2,
        "name": "bench_ufunc.Custom.time_not_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Custom.time_or_bool": {
        "code": "class Custom:\n    def time_or_bool(self):\n        (self.b | self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)",
        "min_run_count": 2,
        "name": "bench_ufunc.Custom.time_or_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomArrayFloorDivideInt.time_floor_divide_int": {
        "code": "class CustomArrayFloorDivideInt:\n    def time_floor_divide_int(self, dtype, size):\n        self.x // self.y\n\n    def setup(self, dtype, size):\n        iinfo = np.iinfo(dtype)\n        self.x = np.random.randint(\n                    iinfo.min, iinfo.max, size=size, dtype=dtype)\n        self.y = np.random.randint(2, 32, size=size, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomArrayFloorDivideInt.time_floor_divide_int",
        "number": 0,
        "param_names": [
            "dtype",
            "size"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.longlong'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.ulonglong'>"
            ],
            [
                "100",
                "10000",
                "1000000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomComparison.time_less_than_binary": {
        "code": "class CustomComparison:\n    def time_less_than_binary(self, dtype):\n        (self.x < self.y)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomComparison.time_less_than_binary",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'numpy.bool'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomComparison.time_less_than_scalar1": {
        "code": "class CustomComparison:\n    def time_less_than_scalar1(self, dtype):\n        (self.s < self.x)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomComparison.time_less_than_scalar1",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'numpy.bool'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomComparison.time_less_than_scalar2": {
        "code": "class CustomComparison:\n    def time_less_than_scalar2(self, dtype):\n        (self.x < self.s)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomComparison.time_less_than_scalar2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.uint8'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>",
                "<class 'numpy.bool'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_char_or": {
        "code": "class CustomInplace:\n    def time_char_or(self):\n        np.bitwise_or(self.c, 0, out=self.c)\n        np.bitwise_or(0, self.c, out=self.c)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_char_or",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_char_or_temp": {
        "code": "class CustomInplace:\n    def time_char_or_temp(self):\n        0 | self.c | 0\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_char_or_temp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_double_add": {
        "code": "class CustomInplace:\n    def time_double_add(self):\n        np.add(self.d, 1., out=self.d)\n        np.add(1., self.d, out=self.d)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_double_add",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_double_add_temp": {
        "code": "class CustomInplace:\n    def time_double_add_temp(self):\n        1. + self.d + 1.\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_double_add_temp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_float_add": {
        "code": "class CustomInplace:\n    def time_float_add(self):\n        np.add(self.f, 1., out=self.f)\n        np.add(1., self.f, out=self.f)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_float_add",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_float_add_temp": {
        "code": "class CustomInplace:\n    def time_float_add_temp(self):\n        1. + self.f + 1.\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_float_add_temp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_int_or": {
        "code": "class CustomInplace:\n    def time_int_or(self):\n        np.bitwise_or(self.i, 0, out=self.i)\n        np.bitwise_or(0, self.i, out=self.i)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_int_or",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomInplace.time_int_or_temp": {
        "code": "class CustomInplace:\n    def time_int_or_temp(self):\n        0 | self.i | 0\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomInplace.time_int_or_temp",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomScalar.time_add_scalar2": {
        "code": "class CustomScalar:\n    def time_add_scalar2(self, dtype):\n        np.add(self.d, 1)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomScalar.time_add_scalar2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomScalar.time_divide_scalar2": {
        "code": "class CustomScalar:\n    def time_divide_scalar2(self, dtype):\n        np.divide(self.d, 1)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomScalar.time_divide_scalar2",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomScalar.time_divide_scalar2_inplace": {
        "code": "class CustomScalar:\n    def time_divide_scalar2_inplace(self, dtype):\n        np.divide(self.d, 1, out=self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomScalar.time_divide_scalar2_inplace",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomScalarFloorDivideInt.time_floor_divide_int": {
        "code": "class CustomScalarFloorDivideInt:\n    def time_floor_divide_int(self, dtype, divisor):\n        self.x // divisor\n\n    def setup(self, dtype, divisor):\n        iinfo = np.iinfo(dtype)\n        self.x = np.random.randint(\n                    iinfo.min, iinfo.max, size=10000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomScalarFloorDivideInt.time_floor_divide_int",
        "number": 0,
        "param_names": [
            "dtype",
            "divisors"
        ],
        "params": [
            [
                "<class 'numpy.int8'>",
                "<class 'numpy.int16'>",
                "<class 'numpy.int32'>",
                "<class 'numpy.int64'>",
                "<class 'numpy.longlong'>"
            ],
            [
                "8",
                "-8",
                "43",
                "-43"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.CustomScalarFloorDivideUInt.time_floor_divide_uint": {
        "code": "class CustomScalarFloorDivideUInt:\n    def time_floor_divide_uint(self, dtype, divisor):\n        self.x // divisor\n\n    def setup(self, dtype, divisor):\n        iinfo = np.iinfo(dtype)\n        self.x = np.random.randint(\n                    iinfo.min, iinfo.max, size=10000, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_ufunc.CustomScalarFloorDivideUInt.time_floor_divide_uint",
        "number": 0,
        "param_names": [
            "dtype",
            "divisors"
        ],
        "params": [
            [
                "<class 'numpy.uint8'>",
                "<class 'numpy.uint16'>",
                "<class 'numpy.uint32'>",
                "<class 'numpy.uint64'>",
                "<class 'numpy.ulonglong'>"
            ],
            [
                "8",
                "43"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.DLPMethods.time_ndarray_dlp": {
        "code": "class DLPMethods:\n    def time_ndarray_dlp(self, methname, npdtypes):\n        meth = getattr(self.xarg, methname)\n        meth()\n\n    def setup(self, methname, npdtypes):\n        values = get_squares_()\n        if npdtypes == 'bool':\n            if version.parse(np.__version__) > version.parse(\"1.25\"):\n                self.xarg = values.get('int16')[0].astype('bool')\n            else:\n                raise NotImplementedError(\"Not supported before v1.25\")\n        else:\n            self.xarg = values.get('int16')[0]",
        "min_run_count": 2,
        "name": "bench_ufunc.DLPMethods.time_ndarray_dlp",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__dlpack__'",
                "'__dlpack_device__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'",
                "'bool'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Methods0DBoolComplex.time_ndarray__0d__": {
        "code": "class Methods0DBoolComplex:\n    def time_ndarray__0d__(self, methname, npdtypes):\n        meth = getattr(self.xarg, methname)\n        meth()\n\n    def setup(self, methname, npdtypes):\n        self.xarg = np.array(3, dtype=npdtypes)",
        "min_run_count": 2,
        "name": "bench_ufunc.Methods0DBoolComplex.time_ndarray__0d__",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__bool__'",
                "'__complex__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Methods0DFloatInt.time_ndarray__0d__": {
        "code": "class Methods0DFloatInt:\n    def time_ndarray__0d__(self, methname, npdtypes):\n        meth = getattr(self.xarg, methname)\n        meth()\n\n    def setup(self, methname, npdtypes):\n        self.xarg = np.array(3, dtype=npdtypes)",
        "min_run_count": 2,
        "name": "bench_ufunc.Methods0DFloatInt.time_ndarray__0d__",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__int__'",
                "'__float__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Methods0DInvert.time_ndarray__0d__": {
        "code": "class Methods0DInvert:\n    def time_ndarray__0d__(self, npdtypes):\n        self.xarg.__invert__()\n\n    def setup(self, npdtypes):\n        self.xarg = np.array(3, dtype=npdtypes)",
        "min_run_count": 2,
        "name": "bench_ufunc.Methods0DInvert.time_ndarray__0d__",
        "number": 0,
        "param_names": [
            "npdtypes"
        ],
        "params": [
            [
                "'int16'",
                "'int32'",
                "'int64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.MethodsV0.time_ndarray_meth": {
        "code": "class MethodsV0:\n    def time_ndarray_meth(self, methname, npdtypes):\n        getattr(operator, methname)(self.xarg)\n\n    def setup(self, methname, npdtypes):\n        values = get_squares_()\n        self.xarg = values.get(npdtypes)[0]",
        "min_run_count": 2,
        "name": "bench_ufunc.MethodsV0.time_ndarray_meth",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__abs__'",
                "'__neg__'",
                "'__pos__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.MethodsV1.time_ndarray_meth": {
        "code": "class MethodsV1:\n    def time_ndarray_meth(self, methname, npdtypes):\n        getattr(operator, methname)(*self.xargs)\n\n    def setup(self, methname, npdtypes):\n        values = get_squares_().get(npdtypes)\n        self.xargs = [values[0], values[1]]\n        if np.issubdtype(npdtypes, np.inexact):\n            # avoid overflow in __pow__/__matmul__ for low-precision dtypes\n            self.xargs[1] *= 0.01",
        "min_run_count": 2,
        "name": "bench_ufunc.MethodsV1.time_ndarray_meth",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__add__'",
                "'__eq__'",
                "'__ge__'",
                "'__gt__'",
                "'__le__'",
                "'__lt__'",
                "'__matmul__'",
                "'__mul__'",
                "'__ne__'",
                "'__pow__'",
                "'__sub__'",
                "'__truediv__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'",
                "'complex64'",
                "'complex128'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.MethodsV1IntOnly.time_ndarray_meth": {
        "code": "class MethodsV1IntOnly:\n    def time_ndarray_meth(self, methname, npdtypes):\n        getattr(operator, methname)(*self.xargs)\n\n    def setup(self, methname, npdtypes):\n        values = get_squares_().get(npdtypes)\n        self.xargs = [values[0], values[1]]",
        "min_run_count": 2,
        "name": "bench_ufunc.MethodsV1IntOnly.time_ndarray_meth",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__and__'",
                "'__or__'",
                "'__xor__'"
            ],
            [
                "'int16'",
                "'int32'",
                "'int64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.MethodsV1NoComplex.time_ndarray_meth": {
        "code": "class MethodsV1NoComplex:\n    def time_ndarray_meth(self, methname, npdtypes):\n        getattr(operator, methname)(*self.xargs)\n\n    def setup(self, methname, npdtypes):\n        values = get_squares_().get(npdtypes)\n        self.xargs = [values[0], values[1]]",
        "min_run_count": 2,
        "name": "bench_ufunc.MethodsV1NoComplex.time_ndarray_meth",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__floordiv__'",
                "'__mod__'"
            ],
            [
                "'int16'",
                "'float16'",
                "'int32'",
                "'float32'",
                "'int64'",
                "'float64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.NDArrayAsType.time_astype": {
        "code": "class NDArrayAsType:\n    def time_astype(self, typeconv):\n        self.xarg.astype(typeconv[1])\n\n    def setup(self, typeconv):\n        if typeconv[0] == typeconv[1]:\n            raise NotImplementedError(\n                    \"Skipping test for converting to the same dtype\")\n        self.xarg = get_squares_().get(typeconv[0])",
        "min_run_count": 2,
        "name": "bench_ufunc.NDArrayAsType.time_astype",
        "number": 0,
        "param_names": [
            "typeconv"
        ],
        "params": [
            [
                "('int16', 'float16')",
                "('int16', 'int32')",
                "('int16', 'float32')",
                "('int16', 'int64')",
                "('int16', 'float64')",
                "('int16', 'complex64')",
                "('int16', 'complex128')",
                "('float16', 'int32')",
                "('float16', 'float32')",
                "('float16', 'int64')",
                "('float16', 'float64')",
                "('float16', 'complex64')",
                "('float16', 'complex128')",
                "('int32', 'float32')",
                "('int32', 'int64')",
                "('int32', 'float64')",
                "('int32', 'complex64')",
                "('int32', 'complex128')",
                "('float32', 'int64')",
                "('float32', 'float64')",
                "('float32', 'complex64')",
                "('float32', 'complex128')",
                "('int64', 'float64')",
                "('int64', 'complex64')",
                "('int64', 'complex128')",
                "('float64', 'complex64')",
                "('float64', 'complex128')",
                "('complex64', 'complex128')"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.NDArrayGetItem.time_methods_getitem": {
        "code": "class NDArrayGetItem:\n    def time_methods_getitem(self, margs, msize):\n        if msize == 'small':\n            mdat = self.xs\n        elif msize == 'big':\n            mdat = self.xl\n        getattr(mdat, '__getitem__')(margs)\n\n    def setup(self, margs, msize):\n        self.xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        self.xl = np.random.uniform(-1, 1, 50*50).reshape(50, 50)",
        "min_run_count": 2,
        "name": "bench_ufunc.NDArrayGetItem.time_methods_getitem",
        "number": 0,
        "param_names": [
            "margs",
            "msize"
        ],
        "params": [
            [
                "0",
                "(0, 0)",
                "(-1, 0)",
                "[0, -1]"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.NDArrayLRShifts.time_ndarray_meth": {
        "code": "class NDArrayLRShifts:\n    def time_ndarray_meth(self, methname, npdtypes):\n        getattr(operator, methname)(*[self.vals, 2])\n\n    def setup(self, methname, npdtypes):\n        self.vals = np.ones(1000,\n                            dtype=getattr(np, npdtypes)) * \\\n                            np.random.randint(9)",
        "min_run_count": 2,
        "name": "bench_ufunc.NDArrayLRShifts.time_ndarray_meth",
        "number": 0,
        "param_names": [
            "methods",
            "npdtypes"
        ],
        "params": [
            [
                "'__lshift__'",
                "'__rshift__'"
            ],
            [
                "'intp'",
                "'int8'",
                "'int16'",
                "'int32'",
                "'int64'",
                "'uint8'",
                "'uint16'",
                "'uint32'",
                "'uint64'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.NDArraySetItem.time_methods_setitem": {
        "code": "class NDArraySetItem:\n    def time_methods_setitem(self, margs, msize):\n        if msize == 'small':\n            mdat = self.xs\n        elif msize == 'big':\n            mdat = self.xl\n            mdat[margs] = 17\n\n    def setup(self, margs, msize):\n        self.xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        self.xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)",
        "min_run_count": 2,
        "name": "bench_ufunc.NDArraySetItem.time_methods_setitem",
        "number": 0,
        "param_names": [
            "margs",
            "msize"
        ],
        "params": [
            [
                "0",
                "(0, 0)",
                "(-1, 0)",
                "[0, -1]"
            ],
            [
                "'small'",
                "'big'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Scalar.time_add_scalar": {
        "code": "class Scalar:\n    def time_add_scalar(self):\n        (self.x + self.x)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray(1.0 + 1j)\n        self.z = complex(1.0, 1.0)",
        "min_run_count": 2,
        "name": "bench_ufunc.Scalar.time_add_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Scalar.time_add_scalar_conv": {
        "code": "class Scalar:\n    def time_add_scalar_conv(self):\n        (self.x + 1.0)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray(1.0 + 1j)\n        self.z = complex(1.0, 1.0)",
        "min_run_count": 2,
        "name": "bench_ufunc.Scalar.time_add_scalar_conv",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.Scalar.time_add_scalar_conv_complex": {
        "code": "class Scalar:\n    def time_add_scalar_conv_complex(self):\n        (self.y + self.z)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray(1.0 + 1j)\n        self.z = complex(1.0, 1.0)",
        "min_run_count": 2,
        "name": "bench_ufunc.Scalar.time_add_scalar_conv_complex",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFunc.time_ufunc_types": {
        "code": "class UFunc:\n    def time_ufunc_types(self, ufuncname):\n        [self.ufn(*arg) for arg in self.args]\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.ufn = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.args = []\n        for _, aarg in get_squares_().items():\n            arg = (aarg,) * self.ufn.nin\n            try:\n                self.ufn(*arg)\n            except TypeError:\n                continue\n            self.args.append(arg)",
        "min_run_count": 2,
        "name": "bench_ufunc.UFunc.time_ufunc_types",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'absolute'",
                "'add'",
                "'arccos'",
                "'arccosh'",
                "'arcsin'",
                "'arcsinh'",
                "'arctan'",
                "'arctan2'",
                "'arctanh'",
                "'bitwise_and'",
                "'bitwise_count'",
                "'bitwise_not'",
                "'bitwise_or'",
                "'bitwise_xor'",
                "'cbrt'",
                "'ceil'",
                "'conj'",
                "'conjugate'",
                "'copysign'",
                "'cos'",
                "'cosh'",
                "'deg2rad'",
                "'degrees'",
                "'divide'",
                "'divmod'",
                "'equal'",
                "'exp'",
                "'exp2'",
                "'expm1'",
                "'fabs'",
                "'float_power'",
                "'floor'",
                "'floor_divide'",
                "'fmax'",
                "'fmin'",
                "'fmod'",
                "'frexp'",
                "'gcd'",
                "'greater'",
                "'greater_equal'",
                "'heaviside'",
                "'hypot'",
                "'invert'",
                "'isfinite'",
                "'isinf'",
                "'isnan'",
                "'isnat'",
                "'lcm'",
                "'ldexp'",
                "'left_shift'",
                "'less'",
                "'less_equal'",
                "'log'",
                "'log10'",
                "'log1p'",
                "'log2'",
                "'logaddexp'",
                "'logaddexp2'",
                "'logical_and'",
                "'logical_not'",
                "'logical_or'",
                "'logical_xor'",
                "'matmul'",
                "'maximum'",
                "'minimum'",
                "'mod'",
                "'modf'",
                "'multiply'",
                "'negative'",
                "'nextafter'",
                "'not_equal'",
                "'positive'",
                "'power'",
                "'rad2deg'",
                "'radians'",
                "'reciprocal'",
                "'remainder'",
                "'right_shift'",
                "'rint'",
                "'sign'",
                "'signbit'",
                "'sin'",
                "'sinh'",
                "'spacing'",
                "'sqrt'",
                "'square'",
                "'subtract'",
                "'tan'",
                "'tanh'",
                "'true_divide'",
                "'trunc'",
                "'vecdot'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFuncSmall.time_ufunc_numpy_scalar": {
        "code": "class UFuncSmall:\n    def time_ufunc_numpy_scalar(self, ufuncname):\n        self.f(self.float64)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1",
        "min_run_count": 2,
        "name": "bench_ufunc.UFuncSmall.time_ufunc_numpy_scalar",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'sqrt'",
                "'cos'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFuncSmall.time_ufunc_python_float": {
        "code": "class UFuncSmall:\n    def time_ufunc_python_float(self, ufuncname):\n        self.f(self.python_float)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1",
        "min_run_count": 2,
        "name": "bench_ufunc.UFuncSmall.time_ufunc_python_float",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'sqrt'",
                "'cos'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFuncSmall.time_ufunc_small_array": {
        "code": "class UFuncSmall:\n    def time_ufunc_small_array(self, ufuncname):\n        self.f(self.array_5)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1",
        "min_run_count": 2,
        "name": "bench_ufunc.UFuncSmall.time_ufunc_small_array",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'sqrt'",
                "'cos'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFuncSmall.time_ufunc_small_array_inplace": {
        "code": "class UFuncSmall:\n    def time_ufunc_small_array_inplace(self, ufuncname):\n        self.f(self.array_5, out = self.array_5)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1",
        "min_run_count": 2,
        "name": "bench_ufunc.UFuncSmall.time_ufunc_small_array_inplace",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'sqrt'",
                "'cos'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc.UFuncSmall.time_ufunc_small_int_array": {
        "code": "class UFuncSmall:\n    def time_ufunc_small_int_array(self, ufuncname):\n        self.f(self.array_int_3)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1",
        "min_run_count": 2,
        "name": "bench_ufunc.UFuncSmall.time_ufunc_small_int_array",
        "number": 0,
        "param_names": [
            "ufunc"
        ],
        "params": [
            [
                "'abs'",
                "'sqrt'",
                "'cos'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "<module 'packaging.version' from '/home/ubuntu/.local/lib/python3.12/site-packages/packaging/version.py'>",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryComplex.time_binary": {
        "code": "class _AbstractBinary:\n    def time_binary(self, ufunc, stride_in0, stride_in1, stride_out,\n             dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryComplex.time_binary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'divide'>"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'F'",
                "'D'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "43a0368435bbebd1fb9a8a81550a8960daa5552701540a55b0bede6ad03a6cd4",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryComplex.time_binary_scalar_in0": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in0(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0][0], *self.ufunc_args[1:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryComplex.time_binary_scalar_in0",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'divide'>"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'F'",
                "'D'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "2b3c224be3779a4c383821cf89a902d9437450f7b4f19b841670ed4c9d96425e",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryComplex.time_binary_scalar_in1": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in1(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0], self.ufunc_args[1][0], *self.ufunc_args[2:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryComplex.time_binary_scalar_in1",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'divide'>"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'F'",
                "'D'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "644f32bc2681d38a6e90928725abb8fc8bb74403756fde38d859a3e7b13a547c",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFP.time_binary": {
        "code": "class _AbstractBinary:\n    def time_binary(self, ufunc, stride_in0, stride_in1, stride_out,\n             dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFP.time_binary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "43a0368435bbebd1fb9a8a81550a8960daa5552701540a55b0bede6ad03a6cd4",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFP.time_binary_scalar_in0": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in0(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0][0], *self.ufunc_args[1:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFP.time_binary_scalar_in0",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "2b3c224be3779a4c383821cf89a902d9437450f7b4f19b841670ed4c9d96425e",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFP.time_binary_scalar_in1": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in1(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0], self.ufunc_args[1][0], *self.ufunc_args[2:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFP.time_binary_scalar_in1",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "644f32bc2681d38a6e90928725abb8fc8bb74403756fde38d859a3e7b13a547c",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFPSpecial.time_binary": {
        "code": "class _AbstractBinary:\n    def time_binary(self, ufunc, stride_in0, stride_in1, stride_out,\n             dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFPSpecial.time_binary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "43a0368435bbebd1fb9a8a81550a8960daa5552701540a55b0bede6ad03a6cd4",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFPSpecial.time_binary_scalar_in0": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in0(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0][0], *self.ufunc_args[1:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFPSpecial.time_binary_scalar_in0",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "2b3c224be3779a4c383821cf89a902d9437450f7b4f19b841670ed4c9d96425e",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryFPSpecial.time_binary_scalar_in1": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in1(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0], self.ufunc_args[1][0], *self.ufunc_args[2:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryFPSpecial.time_binary_scalar_in1",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>",
                "<ufunc 'fmax'>",
                "<ufunc 'fmin'>",
                "<ufunc 'ldexp'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "644f32bc2681d38a6e90928725abb8fc8bb74403756fde38d859a3e7b13a547c",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryInt.time_binary": {
        "code": "class _AbstractBinary:\n    def time_binary(self, ufunc, stride_in0, stride_in1, stride_out,\n             dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryInt.time_binary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "43a0368435bbebd1fb9a8a81550a8960daa5552701540a55b0bede6ad03a6cd4",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryInt.time_binary_scalar_in0": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in0(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0][0], *self.ufunc_args[1:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryInt.time_binary_scalar_in0",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "2b3c224be3779a4c383821cf89a902d9437450f7b4f19b841670ed4c9d96425e",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryInt.time_binary_scalar_in1": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in1(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0], self.ufunc_args[1][0], *self.ufunc_args[2:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryInt.time_binary_scalar_in1",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'maximum'>",
                "<ufunc 'minimum'>"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "1",
                "2"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "644f32bc2681d38a6e90928725abb8fc8bb74403756fde38d859a3e7b13a547c",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryIntContig.time_binary": {
        "code": "class _AbstractBinary:\n    def time_binary(self, ufunc, stride_in0, stride_in1, stride_out,\n             dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryIntContig.time_binary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'bitwise_and'>",
                "<ufunc 'bitwise_or'>",
                "<ufunc 'bitwise_xor'>",
                "<ufunc 'logical_and'>",
                "<ufunc 'logical_or'>",
                "<ufunc 'logical_xor'>",
                "<ufunc 'right_shift'>",
                "<ufunc 'left_shift'>"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "43a0368435bbebd1fb9a8a81550a8960daa5552701540a55b0bede6ad03a6cd4",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryIntContig.time_binary_scalar_in0": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in0(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0][0], *self.ufunc_args[1:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryIntContig.time_binary_scalar_in0",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'bitwise_and'>",
                "<ufunc 'bitwise_or'>",
                "<ufunc 'bitwise_xor'>",
                "<ufunc 'logical_and'>",
                "<ufunc 'logical_or'>",
                "<ufunc 'logical_xor'>",
                "<ufunc 'right_shift'>",
                "<ufunc 'left_shift'>"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "2b3c224be3779a4c383821cf89a902d9437450f7b4f19b841670ed4c9d96425e",
        "warmup_time": -1
    },
    "bench_ufunc_strides.BinaryIntContig.time_binary_scalar_in1": {
        "code": "class _AbstractBinary:\n    def time_binary_scalar_in1(self, ufunc, stride_in0, stride_in1,\n                        stride_out, dtype):\n        ufunc(self.ufunc_args[0], self.ufunc_args[1][0], *self.ufunc_args[2:])\n\n    def setup(self, ufunc, stride_in0, stride_in1, stride_out, dtype):\n        ufunc_insig = f'{dtype}{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            for st_sig in (ufunc_insig, dtype):\n                test = [sig for sig in ufunc.types if sig.startswith(st_sig)]\n                if test:\n                    break\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"binary input of dtype {dtype}\"\n                ) from None\n            tin, tout = test[0].split('->')\n        else:\n            tin = dtype + dtype\n            tout = dtype\n    \n        self.ufunc_args = []\n        for i, (dt, stride) in enumerate(zip(tin, (stride_in0, stride_in1))):\n            self.ufunc_args += [get_data(\n                self.arrlen*stride, dt, i,\n                zeros=self.data_zeros,\n                finite=self.data_finite,\n                denormal=self.data_denormal,\n            )[::stride]]\n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.BinaryIntContig.time_binary_scalar_in1",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in0",
            "stride_in1",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'add'>",
                "<ufunc 'subtract'>",
                "<ufunc 'multiply'>",
                "<ufunc 'bitwise_and'>",
                "<ufunc 'bitwise_or'>",
                "<ufunc 'bitwise_xor'>",
                "<ufunc 'logical_and'>",
                "<ufunc 'logical_or'>",
                "<ufunc 'logical_xor'>",
                "<ufunc 'right_shift'>",
                "<ufunc 'left_shift'>"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "644f32bc2681d38a6e90928725abb8fc8bb74403756fde38d859a3e7b13a547c",
        "warmup_time": -1
    },
    "bench_ufunc_strides.LogisticRegression.time_train": {
        "code": "class LogisticRegression:\n    def time_train(self, dtype):\n        self.train(1000)\n\n    def setup(self, dtype):\n        np.random.seed(42)\n        self.size = 250\n        features = 16\n        self.X_train = np.random.rand(self.size,features).astype(dtype)\n        self.Y_train = np.random.choice(2,self.size).astype(dtype)\n        # Initialize weights\n        self.W = np.zeros((features,1), dtype=dtype)\n        self.b = np.zeros((1,1), dtype=dtype)\n        self.alpha = 0.1",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.LogisticRegression.time_train",
        "number": 0,
        "param_names": [
            "dtype"
        ],
        "params": [
            [
                "<class 'numpy.float32'>",
                "<class 'numpy.float64'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 1000,
        "type": "time",
        "unit": "seconds",
        "version": "e86e16eb2784715dd92cc28fe3cf3d4b7cd03bbfb23570674abc1d06d35e8505",
        "warmup_time": -1
    },
    "bench_ufunc_strides.Mandelbrot.time_mandel": {
        "code": "class Mandelbrot:\n    def time_mandel(self):\n        self.mandelbrot_set(-0.74877,-0.74872,0.06505,0.06510,1000,1000,2048)",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.Mandelbrot.time_mandel",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "74f62bffab8b9720277f099c1fb8d06c8eb635599e335a58345cf121cd5a7b59",
        "warmup_time": -1
    },
    "bench_ufunc_strides.UnaryComplex.time_unary": {
        "code": "class _AbstractUnary:\n    def time_unary(self, ufunc, stride_in, stride_out, dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in, stride_out, dtype):\n        arr_in = get_data(\n            stride_in*self.arrlen, dtype,\n            zeros=self.data_zeros,\n            finite=self.data_finite,\n            denormal=self.data_denormal,\n        )\n        self.ufunc_args = [arr_in[::stride_in]]\n    \n        ufunc_insig = f'{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            test = [sig for sig in ufunc.types if sig.startswith(ufunc_insig)]\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"unary input of dtype {dtype}\"\n                ) from None\n            tout = test[0].split('->')[1]\n        else:\n            tout = dtype\n    \n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.UnaryComplex.time_unary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'reciprocal'>",
                "<ufunc 'absolute'>",
                "<ufunc 'square'>",
                "<ufunc 'conjugate'>"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "1",
                "2",
                "4"
            ],
            [
                "'F'",
                "'D'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "742001542e0113945214791a773180dd4285f539b540b155210e1e1580bcc7a1",
        "warmup_time": -1
    },
    "bench_ufunc_strides.UnaryFP.time_unary": {
        "code": "class _AbstractUnary:\n    def time_unary(self, ufunc, stride_in, stride_out, dtype):\n        ufunc(*self.ufunc_args)\n\nclass UnaryFP:\n    def setup(self, ufunc, stride_in, stride_out, dtype):\n        _AbstractUnary.setup(self, ufunc, stride_in, stride_out, dtype)\n        if (ufunc.__name__ == 'arccosh'):\n            self.ufunc_args[0] += 1.0",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.UnaryFP.time_unary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'absolute'>",
                "<ufunc 'arccos'>",
                "<ufunc 'arccosh'>",
                "<ufunc 'arcsin'>",
                "<ufunc 'arcsinh'>",
                "<ufunc 'arctan'>",
                "<ufunc 'arctanh'>",
                "<ufunc 'cbrt'>",
                "<ufunc 'ceil'>",
                "<ufunc 'conjugate'> (0)",
                "<ufunc 'cos'>",
                "<ufunc 'cosh'>",
                "<ufunc 'deg2rad'>",
                "<ufunc 'degrees'>",
                "<ufunc 'exp'>",
                "<ufunc 'exp2'>",
                "<ufunc 'expm1'>",
                "<ufunc 'fabs'>",
                "<ufunc 'floor'>",
                "<ufunc 'log'>",
                "<ufunc 'log10'>",
                "<ufunc 'log1p'>",
                "<ufunc 'log2'>",
                "<ufunc 'logical_not'>",
                "<ufunc 'negative'>",
                "<ufunc 'positive'>",
                "<ufunc 'rad2deg'>",
                "<ufunc 'radians'>",
                "<ufunc 'reciprocal'>",
                "<ufunc 'rint'>",
                "<ufunc 'sign'>",
                "<ufunc 'sin'>",
                "<ufunc 'sinh'>",
                "<ufunc 'sqrt'>",
                "<ufunc 'square'>",
                "<ufunc 'tan'>",
                "<ufunc 'tanh'>",
                "<ufunc 'trunc'>",
                "<ufunc 'conjugate'> (1)",
                "<ufunc '_ones_like'>"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2"
            ],
            [
                "'e'",
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "93e9ea82d7b369a633efc411965c0ba2bb258c2172210d0d75f9305a3df358ed",
        "warmup_time": -1
    },
    "bench_ufunc_strides.UnaryFPSpecial.time_unary": {
        "code": "class _AbstractUnary:\n    def time_unary(self, ufunc, stride_in, stride_out, dtype):\n        ufunc(*self.ufunc_args)\n\nclass UnaryFP:\n    def setup(self, ufunc, stride_in, stride_out, dtype):\n        _AbstractUnary.setup(self, ufunc, stride_in, stride_out, dtype)\n        if (ufunc.__name__ == 'arccosh'):\n            self.ufunc_args[0] += 1.0",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.UnaryFPSpecial.time_unary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'absolute'>",
                "<ufunc 'arccos'>",
                "<ufunc 'arccosh'>",
                "<ufunc 'arcsin'>",
                "<ufunc 'arcsinh'>",
                "<ufunc 'arctan'>",
                "<ufunc 'arctanh'>",
                "<ufunc 'cbrt'>",
                "<ufunc 'ceil'>",
                "<ufunc 'conjugate'> (0)",
                "<ufunc 'cos'>",
                "<ufunc 'cosh'>",
                "<ufunc 'deg2rad'>",
                "<ufunc 'degrees'>",
                "<ufunc 'exp'>",
                "<ufunc 'exp2'>",
                "<ufunc 'expm1'>",
                "<ufunc 'fabs'>",
                "<ufunc 'floor'>",
                "<ufunc 'log'>",
                "<ufunc 'log10'>",
                "<ufunc 'log1p'>",
                "<ufunc 'log2'>",
                "<ufunc 'logical_not'>",
                "<ufunc 'negative'>",
                "<ufunc 'positive'>",
                "<ufunc 'rad2deg'>",
                "<ufunc 'radians'>",
                "<ufunc 'reciprocal'>",
                "<ufunc 'rint'>",
                "<ufunc 'sign'>",
                "<ufunc 'sin'>",
                "<ufunc 'sinh'>",
                "<ufunc 'sqrt'>",
                "<ufunc 'square'>",
                "<ufunc 'tan'>",
                "<ufunc 'tanh'>",
                "<ufunc 'trunc'>",
                "<ufunc 'conjugate'> (1)",
                "<ufunc '_ones_like'>"
            ],
            [
                "1",
                "4"
            ],
            [
                "1",
                "2"
            ],
            [
                "'e'",
                "'f'",
                "'d'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "93e9ea82d7b369a633efc411965c0ba2bb258c2172210d0d75f9305a3df358ed",
        "warmup_time": -1
    },
    "bench_ufunc_strides.UnaryIntContig.time_unary": {
        "code": "class _AbstractUnary:\n    def time_unary(self, ufunc, stride_in, stride_out, dtype):\n        ufunc(*self.ufunc_args)\n\n    def setup(self, ufunc, stride_in, stride_out, dtype):\n        arr_in = get_data(\n            stride_in*self.arrlen, dtype,\n            zeros=self.data_zeros,\n            finite=self.data_finite,\n            denormal=self.data_denormal,\n        )\n        self.ufunc_args = [arr_in[::stride_in]]\n    \n        ufunc_insig = f'{dtype}->'\n        if ufunc_insig+dtype not in ufunc.types:\n            test = [sig for sig in ufunc.types if sig.startswith(ufunc_insig)]\n            if not test:\n                raise NotImplementedError(\n                    f\"Ufunc {ufunc} doesn't support \"\n                    f\"unary input of dtype {dtype}\"\n                ) from None\n            tout = test[0].split('->')[1]\n        else:\n            tout = dtype\n    \n        for dt in tout:\n            self.ufunc_args += [\n                np.empty(stride_out*self.arrlen, dt)[::stride_out]\n            ]\n    \n        np.seterr(all='ignore')",
        "min_run_count": 2,
        "name": "bench_ufunc_strides.UnaryIntContig.time_unary",
        "number": 0,
        "param_names": [
            "ufunc",
            "stride_in",
            "stride_out",
            "dtype"
        ],
        "params": [
            [
                "<ufunc 'positive'>",
                "<ufunc 'square'>",
                "<ufunc 'reciprocal'>",
                "<ufunc 'conjugate'>",
                "<ufunc 'logical_not'>",
                "<ufunc 'invert'>",
                "<ufunc 'isnan'>",
                "<ufunc 'isinf'>",
                "<ufunc 'isfinite'>",
                "<ufunc 'absolute'>",
                "<ufunc 'sign'>",
                "<ufunc 'bitwise_count'>"
            ],
            [
                "1"
            ],
            [
                "1"
            ],
            [
                "'b'",
                "'B'",
                "'h'",
                "'H'",
                "'i'",
                "'I'",
                "'l'",
                "'L'",
                "'q'",
                "'Q'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10,
        "type": "time",
        "unit": "seconds",
        "version": "742001542e0113945214791a773180dd4285f539b540b155210e1e1580bcc7a1",
        "warmup_time": -1
    },
    "version": 2
}